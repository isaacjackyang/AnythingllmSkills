<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Agent Launch UI</title>
    <style>
      :root {
        --bg-1: #0f172a;
        --bg-2: #1e293b;
        --card: rgba(15, 23, 42, 0.75);
        --text: #e2e8f0;
        --primary: #38bdf8;
        --accent: #f472b6;
        --panel-r1: 60fr;
        --panel-r2: 20fr;
        --panel-r3: 20fr;
        --panel-c1: 1fr;
        --panel-c2: 1fr;
        --dash-r1: 60fr;
        --dash-r2: 40fr;
        --stage-r1: 74fr;
        --stage-r2: 26fr;
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Noto Sans TC", "Microsoft JhengHei", sans-serif;
        color: var(--text);
        background: radial-gradient(circle at top right, #334155, var(--bg-1) 45%),
          linear-gradient(135deg, var(--bg-1), var(--bg-2));
      }

      .panel {
        width: 100vw;
        height: 100vh;
        padding: 1rem;
        background: var(--card);
        border: 1px solid rgba(148, 163, 184, 0.2);
        backdrop-filter: blur(10px);
        display: grid;
        grid-template-rows: minmax(180px, var(--panel-r1)) 10px minmax(140px, var(--panel-r2)) 10px minmax(120px, var(--panel-r3));
        gap: 0.6rem;
      }


      .resizer {
        border-radius: 999px;
        background: rgba(56, 189, 248, 0.32);
        border: 1px solid rgba(125, 211, 252, 0.55);
        cursor: row-resize;
        position: relative;
      }

      .resizer::after {
        content: '';
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 58px;
        height: 3px;
        border-radius: 999px;
        background: rgba(186, 230, 253, 0.95);
      }

      .resizer:focus-visible {
        outline: 2px solid #22d3ee;
        outline-offset: 2px;
      }

      .panel-resizer-top { grid-row: 2; }
      .panel-resizer-bottom { grid-row: 4; }

      .dashboard h1 {
        margin: 0;
        font-size: clamp(1.1rem, 2.4vw, 1.5rem);
      }

      .dashboard p {
        line-height: 1.5;
        color: #cbd5e1;
        margin: 0.55rem 0 0.8rem;
        font-size: 0.9rem;
      }

      .dashboard-main {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 0.65rem 1rem;
      }

      .dashboard-intro {
        flex: 1 1 320px;
        min-width: 0;
      }

      .dashboard-intro p {
        margin-bottom: 0;
      }

      .dashboard-actions {
        display: flex;
        align-items: center;
        gap: 0.65rem;
        flex-wrap: wrap;
      }

      .start-btn {
        border: 0;
        border-radius: 999px;
        font-size: 0.95rem;
        font-weight: 700;
        letter-spacing: 0.02em;
        padding: 0.65rem 1.35rem;
        cursor: pointer;
        color: #0f172a;
        background: linear-gradient(135deg, var(--primary), #22d3ee);
        box-shadow: 0 12px 22px rgba(34, 211, 238, 0.35);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .start-btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 16px 26px rgba(34, 211, 238, 0.45);
      }

      .stage {
        position: relative;
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 20px;
        background: rgba(15, 23, 42, 0.45);
        overflow: hidden;
      }

      .stage-shell {
        display: grid;
        grid-template-rows: minmax(180px, var(--stage-r1)) 10px minmax(140px, var(--stage-r2));
        gap: 0.6rem;
      }

      .stage-shell-resizer {
        grid-row: 2;
        cursor: row-resize;
      }

      .stage-chat {
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.62);
        padding: 0.7rem;
        display: flex;
        flex-direction: column;
        gap: 0.55rem;
      }

      .chat-log {
        margin: 0;
        flex: 1;
        min-height: 88px;
        overflow: auto;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        font-size: 0.75rem;
        color: #bfdbfe;
        white-space: pre-wrap;
      }

      .chat-form {
        display: grid;
        grid-template-columns: minmax(0, 1fr) auto;
        gap: 0.5rem;
      }

      .chat-input {
        width: 100%;
        border: 1px solid rgba(125, 211, 252, 0.45);
        border-radius: 10px;
        background: rgba(15, 23, 42, 0.72);
        color: #e2e8f0;
        padding: 0.55rem 0.65rem;
        font-size: 0.84rem;
      }

      .chat-send {
        border: 1px solid rgba(125, 211, 252, 0.45);
        border-radius: 10px;
        background: rgba(15, 23, 42, 0.82);
        color: #bae6fd;
        font-weight: 700;
        padding: 0.5rem 0.85rem;
        cursor: pointer;
      }

      .stage-agent-panel {
        height: 100%;
        display: flex;
        flex-direction: column;
        gap: 0.7rem;
        padding: 0.8rem;
      }

      .stage-agent-panel h2 {
        margin: 0;
        font-size: 0.95rem;
      }

      .stage-agent-panel p {
        margin: 0;
        color: #cbd5e1;
        font-size: 0.82rem;
        line-height: 1.45;
      }

      .stage-agent-actions {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      .status {
        margin: 0;
        font-size: 0.95rem;
        color: #a5f3fc;
        min-height: 1.2em;
      }

      .dashboard,
      .console {
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.6);
        padding: 0.8rem;
        overflow: hidden;
      }

      .console,
      .console-landscape {
        display: flex;
        flex-direction: column;
        min-height: 0;
      }

      .monitor {
        margin-top: 0.6rem;
        display: grid;
        gap: 0.62rem;
      }

      .pane {
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 14px;
        background: rgba(15, 23, 42, 0.6);
        padding: 0.75rem;
      }

      .resizable-block {
        resize: both;
        overflow: auto;
        min-width: 220px;
        min-height: 120px;
        max-width: 100%;
      }

      .resizable-block.compact {
        min-width: 150px;
        min-height: 72px;
      }

      .resizable-block::-webkit-resizer {
        background: linear-gradient(135deg, transparent 0 45%, rgba(103, 232, 249, 0.85) 45% 55%, transparent 55% 100%);
      }

      .collapsible-block {
        display: flex;
        flex-direction: column;
        min-height: 0;
        transition: border-color 0.2s ease;
      }

      .collapsible-trigger {
        width: 100%;
        border: 1px solid rgba(125, 211, 252, 0.35);
        border-radius: 10px;
        background: rgba(15, 23, 42, 0.75);
        color: #bae6fd;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.6rem;
        padding: 0.4rem 0.6rem;
        font-size: 0.78rem;
        font-weight: 700;
        cursor: pointer;
      }

      .collapsible-chevron {
        font-size: 0.75rem;
        color: #67e8f9;
        transition: transform 0.2s ease;
      }

      .collapsible-block[data-collapsed="true"] .collapsible-chevron {
        transform: rotate(-90deg);
      }

      .collapsible-body {
        min-height: 0;
        flex: 1 1 auto;
        overflow: auto;
      }

      .collapsible-block[data-collapsed="false"] .collapsible-body {
        margin-top: 0.45rem;
      }

      .collapsible-block[data-collapsed="true"] .collapsible-body {
        display: none;
      }

      .collapsible-block[data-collapsed="true"] {
        min-height: 0 !important;
        height: auto !important;
        overflow: visible;
        resize: none;
      }

      .flow-card .collapsible-body,
      .console .collapsible-body,
      .console-landscape .collapsible-body {
        scrollbar-gutter: stable both-edges;
      }

      .metric-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 0.45rem;
        overflow: auto;
      }

      .metric {
        border-radius: 10px;
        background: rgba(30, 41, 59, 0.8);
        border: 1px solid rgba(148, 163, 184, 0.15);
        padding: 0.55rem 0.65rem;
        overflow: auto;
      }

      .metric .label {
        font-size: 0.75rem;
        color: #94a3b8;
      }

      .metric .value {
        margin-top: 0.2rem;
        font-size: 0.95rem;
        font-weight: 700;
        color: #e2e8f0;
      }

      .control-row {
        margin-top: 0.7rem;
        display: flex;
        gap: 0.55rem;
        flex-wrap: wrap;
      }

      .channel-grid {
        margin-top: 0.7rem;
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 0.42rem;
        overflow: auto;
      }

      .channel-card {
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 12px;
        background: rgba(15, 23, 42, 0.62);
        padding: 0.55rem;
        overflow: auto;
      }

      .sortable-item {
        cursor: grab;
      }

      .sortable-item.dragging {
        opacity: 0.45;
        cursor: grabbing;
      }

      .sortable-target {
        outline: 1px dashed rgba(103, 232, 249, 0.9);
        outline-offset: 2px;
      }

      .channel-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
      }

      .channel-name {
        font-size: 0.8rem;
        font-weight: 700;
        color: #e2e8f0;
      }

      .channel-state {
        margin-top: 0.25rem;
        font-size: 0.72rem;
        color: #94a3b8;
      }

      .channel-toggle {
        border: 1px solid rgba(125, 211, 252, 0.45);
        background: rgba(15, 23, 42, 0.8);
        color: #bae6fd;
        border-radius: 8px;
        padding: 0.3rem 0.5rem;
        font-size: 0.72rem;
        cursor: pointer;
      }

      .ctrl-btn {
        border: 1px solid rgba(125, 211, 252, 0.45);
        background: rgba(15, 23, 42, 0.8);
        color: #bae6fd;
        border-radius: 8px;
        padding: 0.45rem 0.72rem;
        font-size: 0.78rem;
        cursor: pointer;
      }

      .ctrl-btn.stop {
        border-color: rgba(251, 113, 133, 0.55);
        color: #fecdd3;
      }

      .console-log {
        margin: 0;
        flex: 1 1 auto;
        min-height: 0;
        overflow-x: hidden;
        overflow-y: auto;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        font-size: 0.76rem;
        line-height: 1.45;
        color: #bfdbfe;
        white-space: pre-wrap;
        word-break: break-word;
      }

      .console h2 {
        margin: 0 0 0.5rem;
        font-size: 0.95rem;
      }

      #consolePane,
      .console-landscape.collapsible-block {
        flex: 1 1 auto;
        min-height: 0;
      }

      .flow-card {
        margin-top: 0.7rem;
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 14px;
        background: rgba(15, 23, 42, 0.56);
        padding: 0.65rem;
      }

      .flow-card h3 {
        margin: 0 0 0.45rem;
        font-size: 0.82rem;
        color: #bfdbfe;
        letter-spacing: 0.02em;
      }


      .task-toolbar {
        margin-bottom: 0.55rem;
        display: flex;
        gap: 0.45rem;
        flex-wrap: wrap;
        align-items: center;
      }

      .task-toolbar select {
        border: 1px solid rgba(125, 211, 252, 0.45);
        background: rgba(15, 23, 42, 0.82);
        color: #bae6fd;
        border-radius: 8px;
        padding: 0.3rem 0.45rem;
        font-size: 0.72rem;
      }

      .task-list {
        display: grid;
        gap: 0.42rem;
        max-height: 220px;
        overflow: auto;
      }

      .task-item {
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 10px;
        background: rgba(15, 23, 42, 0.62);
        padding: 0.45rem;
        display: grid;
        gap: 0.35rem;
      }

      .task-item-head {
        display: flex;
        justify-content: space-between;
        gap: 0.45rem;
        align-items: center;
      }

      .task-name { font-size: 0.78rem; font-weight: 700; color: #e2e8f0; }
      .task-meta { font-size: 0.7rem; color: #94a3b8; }
      .task-actions { display:flex; gap:0.35rem; flex-wrap:wrap; }
      .task-btn {
        border: 1px solid rgba(125, 211, 252, 0.45);
        background: rgba(15, 23, 42, 0.8);
        color: #bae6fd;
        border-radius: 8px;
        padding: 0.24rem 0.45rem;
        font-size: 0.68rem;
        cursor: pointer;
      }
      .task-btn.delete { border-color: rgba(251, 113, 133, 0.55); color: #fecdd3; }
      .task-empty { font-size: 0.74rem; color: #94a3b8; }

      .flow-help {
        margin: 0 0 0.55rem;
        font-size: 0.73rem;
        color: #94a3b8;
      }

      .flow-hint {
        margin-left: 0.4rem;
        color: #67e8f9;
      }

      .flow-svg {
        width: 100%;
        height: 260px;
        display: block;
        border-radius: 10px;
        background: rgba(15, 23, 42, 0.85);
      }

      .flow-legend {
        margin-top: 0.55rem;
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        font-size: 0.7rem;
        color: #cbd5e1;
      }

      .chip {
        border-radius: 999px;
        padding: 0.14rem 0.45rem;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(30, 41, 59, 0.6);
      }

      @media (orientation: landscape) {
        .panel {
          grid-template-columns: minmax(320px, var(--panel-c1)) 14px minmax(320px, var(--panel-c2));
          grid-template-rows: 1fr;
          gap: 0.6rem;
        }

        .stage-shell {
          grid-row: 1;
          grid-column: 1;
          min-width: 0;
        }
        .panel-resizer-top {
          grid-row: 1;
          grid-column: 2;
          display: block;
          min-width: 14px;
          width: 14px;
          align-self: stretch;
          cursor: col-resize;
          z-index: 6;
          touch-action: none;
          border-color: rgba(125, 211, 252, 0.95);
          background: linear-gradient(180deg, rgba(56, 189, 248, 0.68), rgba(14, 116, 144, 0.55));
          box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.45), 0 0 14px rgba(34, 211, 238, 0.28);
        }
        .panel-resizer-top::after {
          width: 6px;
          height: 160px;
          background: rgba(186, 230, 253, 0.98);
        }
        .panel-resizer-bottom { display: none; }
        .dashboard {
          grid-row: 1;
          grid-column: 3;
          min-width: 0;
        }

        .dashboard {
          display: grid;
          grid-template-rows: minmax(180px, var(--dash-r1)) 10px minmax(140px, var(--dash-r2));
          gap: 0.6rem;
        }

        .dashboard-resizer {
          grid-row: 2;
          cursor: row-resize;
        }

        .dashboard-main,
        .console-landscape {
          border: 1px solid rgba(148, 163, 184, 0.2);
          border-radius: 14px;
          background: rgba(15, 23, 42, 0.45);
          padding: 0.75rem;
          overflow: hidden;
        }

        .console { display: none; }
        .console-landscape { display: block; }
      }

      @media (orientation: portrait) {
        .dashboard-main {
          display: block;
        }

        .dashboard-actions {
          margin-top: 0.6rem;
        }

        .status {
          margin-top: 0.35rem;
        }

        .console-landscape { display: none; }
        .dashboard-resizer { display: none; }
      }
    </style>
  </head>
  <body>
    <main class="panel">
      <section class="stage-shell" aria-label="å·¦å´å·¥ä½œå€">
        <section class="stage" aria-label="Agent ç®¡ç†å¿«æ·å€" data-collapsible data-collapsible-label="Agent ç®¡ç†å¿«æ·å€">
          <div class="stage-agent-panel">
            <h2>Agent ç®¡ç†å¿«æ·å€</h2>
            <p>å·²ç§»é™¤åŠ©æ‰‹å‹•ç•«ï¼Œæ”¹ç”± Agent ç®¡ç†è³‡è¨Šå–ä»£ã€‚å¯ç›´æ¥åœ¨æ­¤å¿«é€Ÿæ§åˆ¶ Agent åŸ·è¡Œç‹€æ…‹ã€‚</p>
            <div class="stage-agent-actions">
              <button id="quickStartAgent" class="ctrl-btn" type="button">å•Ÿå‹• Agent</button>
              <button id="quickPauseAgent" class="ctrl-btn" type="button">æš«åœä»»å‹™</button>
              <button id="quickResumeAgent" class="ctrl-btn" type="button">æ¢å¾©ä»»å‹™</button>
              <button id="quickStopAgent" class="ctrl-btn stop" type="button">åœæ­¢ Agent</button>
            </div>
            <pre id="quickAgentSummary" class="console-log" style="min-height: 160px;">[agent] ç­‰å¾…è¼‰å…¥ Agent ç‹€æ…‹...</pre>
          </div>
        </section>

        <div id="stageResizer" class="resizer stage-shell-resizer" role="separator" aria-orientation="horizontal" tabindex="0" aria-label="èª¿æ•´ Agent ç®¡ç†å¿«æ·å€èˆ‡ Agent å°è©±è¼¸å…¥æ¡†é«˜åº¦"></div>

        <section class="stage-chat" aria-label="æŒ‡ä»¤å°è©±æ¡†" data-collapsible data-collapsible-label="Agent å°è©±è¼¸å…¥æ¡†">
          <h2 style="margin:0;font-size:0.92rem;">Agent å°è©±è¼¸å…¥æ¡†</h2>
          <pre id="chatLog" class="chat-log">[chat] å¯åœ¨æ­¤è¼¸å…¥æŒ‡ä»¤ï¼Œå¯é¸æ“‡è·¯å¾‘ï¼šGateway -> AnythingLLM æˆ– Gateway -> Ollama (gpt-oss)</pre>
          <form id="chatForm" class="chat-form">
            <select id="chatPath" class="chat-input" style="max-width: 260px;">
              <option value="anythingllm">ç¶“ AnythingLLMï¼ˆé è¨­ï¼‰</option>
              <option value="ollama">ç›´é€£ Ollamaï¼ˆgpt-ossï¼‰</option>
            </select>
            <input id="chatInput" class="chat-input" type="text" placeholder="ä¾‹å¦‚ï¼šè«‹æ•´ç†ä»Šå¤©å‘Šè­¦ä¸¦æå‡ºè™•ç½®æ­¥é©Ÿ" required />
            <button id="chatSend" class="chat-send" type="submit">é€å‡º</button>
          </form>
          <p id="inferenceRouteStatus" style="margin:6px 0 0;color:#94a3b8;font-size:12px;">è·¯å¾‘æª¢æŸ¥ä¸­...</p>
        </section>
      </section>

      <div id="resizerTop" class="resizer panel-resizer-top" role="separator" aria-orientation="horizontal" tabindex="0" aria-label="èª¿æ•´ä¸Šæ–¹èˆ‡ä¸­é–“å€å¡Šé«˜åº¦"></div>

      <section class="dashboard">
        <div class="dashboard-main">
          <div class="dashboard-intro">
            <h1>Agent å•Ÿå‹•é¢æ¿</h1>
            <p>æ­¡è¿ä½¿ç”¨ Agent æ§åˆ¶å°ã€‚æŒ‰ä¸‹æŒ‰éˆ•å¾Œï¼Œç³»çµ±æœƒåˆå§‹åŒ–æµç¨‹ä¸¦é–‹å§‹åŸ·è¡Œä»»å‹™ã€‚</p>
          </div>
          <div class="dashboard-actions">
            <button id="startAgent" class="start-btn" type="button">Start Agent</button>
            <p id="status" class="status" aria-live="polite"></p>
          </div>

          <section class="monitor" aria-label="Agent dashboard">
            <section id="dashboardPane" class="pane" role="region" aria-label="dashboard" data-collapsible data-collapsible-label="ç³»çµ±æŒ‡æ¨™èˆ‡æ§åˆ¶">
            <div class="metric-grid">
              <article class="metric">
                <div class="label">åŠ©æ‰‹ç‹€æ…‹</div>
                <div id="assistantStatus" class="value">Idle</div>
              </article>
              <article class="metric">
                <div class="label">åŸ·è¡Œç‹€æ…‹</div>
                <div id="executionStatus" class="value">æœªåŸ·è¡Œ</div>
              </article>
              <article class="metric">
                <div class="label">é€²åº¦</div>
                <div id="taskProgress" class="value">0%</div>
              </article>
              <article class="metric">
                <div class="label">ç›®å‰ä»»å‹™åŸ·è¡Œæ™‚é–“</div>
                <div id="taskElapsed" class="value">00:00:00</div>
              </article>
              <article class="metric">
                <div class="label">æœ€å¾Œæ›´æ–°</div>
                <div id="lastUpdated" class="value">--:--:--</div>
              </article>
            </div>
            <div class="control-row">
              <button id="pauseAgent" class="ctrl-btn" type="button">æš«åœä»»å‹™</button>
              <button id="resumeAgent" class="ctrl-btn" type="button">æ¢å¾©ä»»å‹™</button>
              <button id="stopAgent" class="ctrl-btn stop" type="button">åœæ­¢ Agent</button>
              <button id="clearConsole" class="ctrl-btn" type="button">æ¸…é™¤ Console</button>
            </div>
            </section>

            <article class="flow-card" aria-label="é€£å…¥æ¥å£æ§åˆ¶" data-collapsible data-collapsible-label="é€£å…¥æ¥å£å¡ç‰‡èˆ‡é–‹é—œ">
              <h3>é€£å…¥æ¥å£å¡ç‰‡èˆ‡é–‹é—œ</h3>
              <p class="flow-help">å¯ç¨ç«‹å•Ÿç”¨/åœç”¨æ¯å€‹æ¥å£ï¼›åœç”¨å¾Œè©²æ¥å£ ingress æœƒå›å‚³ 503ã€‚</p>
              <div class="channel-grid">
                <section class="channel-card" data-channel-card="telegram" data-collapsible data-collapsible-label="é€šé“ï¼šTelegram">
                  <div class="channel-head">
                    <span class="channel-name">Telegram</span>
                    <button class="channel-toggle" data-channel-toggle="telegram" type="button">åˆ‡æ›</button>
                  </div>
                  <div id="channelStateTelegram" class="channel-state">æœªé€£æ¥ï¼ˆå¾…é‡è©¦ï¼‰</div>
                </section>
                <section class="channel-card" data-channel-card="line" data-collapsible data-collapsible-label="é€šé“ï¼šLINE">
                  <div class="channel-head">
                    <span class="channel-name">LINE</span>
                    <button class="channel-toggle" data-channel-toggle="line" type="button">åˆ‡æ›</button>
                  </div>
                  <div id="channelStateLine" class="channel-state">æœªé€£æ¥ï¼ˆå¾…é‡è©¦ï¼‰</div>
                </section>
                <section class="channel-card" data-channel-card="web_ui" data-collapsible data-collapsible-label="é€šé“ï¼šWeb UI">
                  <div class="channel-head">
                    <span class="channel-name">Web UI</span>
                    <button class="channel-toggle" data-channel-toggle="web_ui" type="button">åˆ‡æ›</button>
                  </div>
                  <div id="channelStateWebUi" class="channel-state">æœªé€£æ¥ï¼ˆå¾…é‡è©¦ï¼‰</div>
                </section>
              </div>
            </article>




            <article class="flow-card" aria-label="Agent ç®¡ç†å€" data-collapsible data-collapsible-label="Agent ç®¡ç†ï¼ˆæ¨¡å‹/éˆé­‚/ä»»å‹™/è¨˜æ†¶ï¼‰">
              <h3>Agent ç®¡ç†å€</h3>
              <p class="flow-help">å¯æ–°å¢å¤šå€‹ Agentï¼›æ¯å€‹ Agent å¯æœ‰ä¸åŒæ¨¡å‹ã€éˆé­‚ã€ä»»å‹™æ¿èˆ‡è¨˜æ†¶ namespaceï¼Œä¸¦å¯è¨­å®šè·¨ Agent é€šè¨Šæ¨¡å¼ã€‚</p>
              <div class="task-toolbar">
                <label for="agentSelect">ç•¶å‰ Agentï¼š</label>
                <select id="agentSelect" style="min-width: 220px;"></select>
                <button id="refreshAgents" class="ctrl-btn" type="button">é‡æ–°æ•´ç† Agent</button>
              </div>
              <div class="task-toolbar" style="margin-top:8px;">
                <input id="newAgentName" class="chat-input" style="max-width:180px;" type="text" placeholder="Agent åç¨±" />
                <input id="newAgentModel" class="chat-input" style="max-width:180px;" type="text" placeholder="æ¨¡å‹ï¼Œä¾‹å¦‚ gpt-oss:20b" />
                <input id="newAgentSoul" class="chat-input" style="max-width:160px;" type="text" placeholder="éˆé­‚ï¼Œä¾‹å¦‚ planner" />
                <select id="newAgentComm" style="max-width:180px;">
                  <option value="hub_and_spoke">é€šä¿¡ï¼šhub-and-spoke</option>
                  <option value="direct">é€šä¿¡ï¼šdirect</option>
                </select>
                <button id="createAgent" class="ctrl-btn" type="button">æ–°å¢ Agent</button>
              </div>
              <pre id="agentInfo" class="console-log" style="min-height:130px;max-height:240px;">[agent] å°šæœªè¼‰å…¥ Agent è¨­å®š</pre>
              <pre id="agentCommInfo" class="console-log" style="min-height:100px;max-height:180px;">[agent] å°šæœªè¼‰å…¥ Agent é€šä¿¡åœ–</pre>
            </article>

            <article class="flow-card" aria-label="ä»»å‹™åˆ—è¡¨" data-collapsible data-collapsible-label="ä»»å‹™åˆ—è¡¨ï¼ˆæ’åº/åˆªé™¤ï¼‰">
              <h3>ä»»å‹™åˆ—è¡¨ï¼ˆå¯æ’åº / åˆªé™¤ï¼‰</h3>
              <p class="flow-help">å¯ä¾å»ºç«‹æ™‚é–“ã€æ›´æ–°æ™‚é–“ã€å„ªå…ˆç´šæ’åºï¼›åƒ…å…è¨±åˆªé™¤çµ‚æ…‹ä»»å‹™ï¼ˆsucceeded / failed / cancelledï¼‰ã€‚</p>
              <div class="task-toolbar">
                <label for="taskSort">æ’åºï¼š</label>
                <select id="taskSort">
                  <option value="created_desc">å»ºç«‹æ™‚é–“ï¼ˆæ–°â†’èˆŠï¼‰</option>
                  <option value="created_asc">å»ºç«‹æ™‚é–“ï¼ˆèˆŠâ†’æ–°ï¼‰</option>
                  <option value="updated_desc">æ›´æ–°æ™‚é–“ï¼ˆæ–°â†’èˆŠï¼‰</option>
                  <option value="priority_desc">å„ªå…ˆç´šï¼ˆé«˜â†’ä½ï¼‰</option>
                </select>
                <button id="refreshTasks" class="ctrl-btn" type="button">é‡æ–°æ•´ç†ä»»å‹™</button>
              </div>
              <div id="taskList" class="task-list">
                <div class="task-empty">å°šæœªè¼‰å…¥ä»»å‹™ã€‚</div>
              </div>
            </article>

            <article class="flow-card" aria-label="è¨˜æ†¶æª”æ¡ˆæª¢è¦–" data-collapsible data-collapsible-label="è¨˜æ†¶æª”æ¡ˆæª¢è¦–">
              <h3>è¨˜æ†¶æª”æ¡ˆæª¢è¦–</h3>
              <p class="flow-help">å¯é¸æ“‡ä¸¦æ‰“é–‹ `MEMORY.md`ã€`memory/`ã€`second-brain/` ä¸‹çš„ Markdown è¨˜æ†¶æª”ã€‚</p>
              <div class="task-toolbar">
                <label for="memoryFileSelect">æª”æ¡ˆï¼š</label>
                <select id="memoryFileSelect" style="min-width: 280px;"></select>
                <button id="refreshMemoryFiles" class="ctrl-btn" type="button">é‡æ–°æ•´ç†è¨˜æ†¶æª”</button>
                <button id="openMemoryFile" class="ctrl-btn" type="button">é–‹å•Ÿæª”æ¡ˆ</button>
              </div>
              <pre id="memoryFileContent" class="console-log" style="min-height:160px;max-height:360px;">[memory] å°šæœªè¼‰å…¥è¨˜æ†¶æª”å…§å®¹</pre>
            </article>

            <article class="flow-card" aria-label="è¨˜æ†¶å›ºå®šæµç¨‹" data-collapsible data-collapsible-label="è¨˜æ†¶å›ºå®šæµç¨‹ï¼ˆè‡ªå‹•åŒ–ï¼‰">
              <h3>è¨˜æ†¶å›ºå®šæµç¨‹ï¼ˆè‡ªå‹•åŒ–ï¼‰</h3>
              <p class="flow-help">å›ºå®šæµç¨‹å¯ä¸€éµåŸ·è¡Œï¼ˆmicroSync / daily wrap-up / weekly compoundï¼‰ï¼›éœ€è¦æ™ºåŠ›åˆ¤æ–·çš„å…§å®¹ä»ç”±æ¨¡å‹æˆ–äººå·¥è™•ç†ã€‚</p>
              <div class="task-toolbar">
                <label for="workflowJobSelect">æµç¨‹ï¼š</label>
                <select id="workflowJobSelect">
                  <option value="microsync">microSync</option>
                  <option value="daily-wrapup">daily wrap-up</option>
                  <option value="weekly-compound">weekly compound</option>
                </select>
                <label for="workflowDateInput">æ—¥æœŸï¼š</label>
                <input id="workflowDateInput" type="date" />
                <label><input id="workflowDryRun" type="checkbox" checked /> dry-run</label>
                <button id="runWorkflowBtn" class="ctrl-btn" type="button">åŸ·è¡Œæµç¨‹</button>
              </div>
              <pre id="workflowResult" class="console-log" style="min-height:120px;max-height:260px;">[workflow] å°šæœªåŸ·è¡Œ</pre>
            </article>

            <article class="flow-card" aria-label="API è³‡æ–™æµ" data-collapsible data-collapsible-label="API è³‡æ–™æµæ‹“æ¨¸">
              <h3>API è³‡æ–™æµæ‹“æ¨¸ï¼ˆå¡ç‰‡å¼ï¼‰</h3>
              <p class="flow-help">ä»¥æ–¹å¡Šå¡ç‰‡å‘ˆç¾ç›®å‰å…ƒä»¶ï¼ˆUI / Gateway / AnythingLLM / Ollama / gpt-oss:20bï¼‰ï¼Œé€£ç·šæ—æ¨™ç¤ºé€šè¨Šæ–¹å¼ï¼ˆAPI / Local Runtimeï¼‰ã€‚<span class="flow-hint">å¯ç›´æ¥æ‹–æ›³å¡ç‰‡èª¿æ•´æ‹“æ¨¸ã€‚</span></p>
              <svg id="flowSvg" class="flow-svg" viewBox="0 0 980 300" role="img" aria-label="UI åˆ° LLM çš„å¯¦éš›è³‡æ–™æµèˆ‡é€šè¨Šæ–¹å¼"></svg>
              <div class="flow-legend">
                <span class="chip">ğŸŸ¢ Active path</span>
                <span class="chip">ğŸŸ¡ Paused path</span>
                <span class="chip">ğŸ”¹ HTTP API / Webhook</span>
                <span class="chip">ğŸ§  Local runtime / provider call</span>
              </div>
            </article>
          </section>
        </div>

        <div id="dashboardResizer" class="resizer dashboard-resizer" role="separator" aria-orientation="horizontal" tabindex="0" aria-label="èª¿æ•´å³å´é¢æ¿èˆ‡ Console é«˜åº¦"></div>

        <section class="console-landscape" aria-label="console" data-collapsible data-collapsible-label="Consoleï¼ˆæ©«å‘ç‰ˆï¼‰" data-collapsible-collapsed>
          <h2>Console</h2>
          <pre id="consoleLogLandscape" class="console-log">[system] ç­‰å¾…å•Ÿå‹•æŒ‡ä»¤...</pre>
        </section>
      </section>

      <div id="resizerBottom" class="resizer panel-resizer-bottom" role="separator" aria-orientation="horizontal" tabindex="0" aria-label="èª¿æ•´ä¸­é–“èˆ‡ä¸‹æ–¹å€å¡Šé«˜åº¦"></div>

      <section class="console" aria-label="console">
        <h2>Console</h2>
        <section id="consolePane" class="pane" role="region" aria-label="console" data-collapsible data-collapsible-label="Console å…§å®¹" data-collapsible-collapsed>
            <pre id="consoleLog" class="console-log">[system] ç­‰å¾…å•Ÿå‹•æŒ‡ä»¤...</pre>
        </section>
      </section>
    </main>

    <script>
      const button = document.getElementById('startAgent');
      const status = document.getElementById('status');
      const assistantStatus = document.getElementById('assistantStatus');
      const executionStatus = document.getElementById('executionStatus');
      const taskProgress = document.getElementById('taskProgress');
      const taskElapsed = document.getElementById('taskElapsed');
      const lastUpdated = document.getElementById('lastUpdated');
      const consoleLog = document.getElementById('consoleLog');
      const consoleLogLandscape = document.getElementById('consoleLogLandscape');
      const pauseBtn = document.getElementById('pauseAgent');
      const resumeBtn = document.getElementById('resumeAgent');
      const stopBtn = document.getElementById('stopAgent');
      const clearConsoleBtn = document.getElementById('clearConsole');
      const channelStateTelegram = document.getElementById('channelStateTelegram');
      const channelStateLine = document.getElementById('channelStateLine');
      const channelStateWebUi = document.getElementById('channelStateWebUi');
      const channelToggleButtons = document.querySelectorAll('[data-channel-toggle]');
      const agentSelect = document.getElementById('agentSelect');
      const refreshAgentsBtn = document.getElementById('refreshAgents');
      const newAgentName = document.getElementById('newAgentName');
      const newAgentModel = document.getElementById('newAgentModel');
      const newAgentSoul = document.getElementById('newAgentSoul');
      const newAgentComm = document.getElementById('newAgentComm');
      const createAgentBtn = document.getElementById('createAgent');
      const agentInfo = document.getElementById('agentInfo');
      const agentCommInfo = document.getElementById('agentCommInfo');
      const taskList = document.getElementById('taskList');
      const taskSort = document.getElementById('taskSort');
      const refreshTasksBtn = document.getElementById('refreshTasks');
      const memoryFileSelect = document.getElementById('memoryFileSelect');
      const refreshMemoryFilesBtn = document.getElementById('refreshMemoryFiles');
      const openMemoryFileBtn = document.getElementById('openMemoryFile');
      const memoryFileContent = document.getElementById('memoryFileContent');
      const workflowJobSelect = document.getElementById('workflowJobSelect');
      const workflowDateInput = document.getElementById('workflowDateInput');
      const workflowDryRun = document.getElementById('workflowDryRun');
      const runWorkflowBtn = document.getElementById('runWorkflowBtn');
      const workflowResult = document.getElementById('workflowResult');
      const flowSvg = document.getElementById('flowSvg');
      const chatForm = document.getElementById('chatForm');
      const chatPath = document.getElementById('chatPath');
      const chatInput = document.getElementById('chatInput');
      const chatSend = document.getElementById('chatSend');
      const inferenceRouteStatus = document.getElementById('inferenceRouteStatus');
      const chatLog = document.getElementById('chatLog');
      const quickStartAgent = document.getElementById('quickStartAgent');
      const quickPauseAgent = document.getElementById('quickPauseAgent');
      const quickResumeAgent = document.getElementById('quickResumeAgent');
      const quickStopAgent = document.getElementById('quickStopAgent');
      const quickAgentSummary = document.getElementById('quickAgentSummary');
      const panelEl = document.querySelector('.panel');
      const dashboardEl = document.querySelector('.dashboard');
      const stageShellEl = document.querySelector('.stage-shell');
      const resizerTop = document.getElementById('resizerTop');
      const resizerBottom = document.getElementById('resizerBottom');
      const dashboardResizer = document.getElementById('dashboardResizer');
      const stageResizer = document.getElementById('stageResizer');


      const initializeResizableBlocks = () => {
        document.querySelectorAll('.stage, .stage-chat, .pane, .flow-card, .channel-card, .metric, .console, .console-landscape')
          .forEach((block) => {
            if (!(block instanceof HTMLElement)) return;
            block.classList.add('resizable-block');
            if (block.classList.contains('channel-card') || block.classList.contains('metric')) {
              block.classList.add('compact');
            }
          });
      };

      const initializeCollapsibleBlocks = () => {
        const blocks = document.querySelectorAll('[data-collapsible]');
        blocks.forEach((block, index) => {
          block.classList.add('collapsible-block');
          const title = block.dataset.collapsibleLabel || block.getAttribute('aria-label') || `å€å¡Š ${index + 1}`;
          const defaultCollapsed = block.hasAttribute('data-collapsible-collapsed');

          const body = document.createElement('div');
          body.className = 'collapsible-body';
          while (block.firstChild) {
            body.appendChild(block.firstChild);
          }

          const trigger = document.createElement('button');
          trigger.type = 'button';
          trigger.className = 'collapsible-trigger';
          trigger.innerHTML = `<span>${title}</span><span class="collapsible-chevron">â–¾</span>`;

          const setCollapsed = (collapsed) => {
            block.dataset.collapsed = collapsed ? 'true' : 'false';
            trigger.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
            trigger.setAttribute('aria-label', `${collapsed ? 'å±•é–‹' : 'æ”¶åˆ'}${title}`);
          };

          trigger.addEventListener('click', () => {
            const collapsed = block.dataset.collapsed === 'true';
            setCollapsed(!collapsed);
          });

          block.appendChild(trigger);
          block.appendChild(body);
          setCollapsed(defaultCollapsed);
        });
      };

      const initializeSortableGrid = (containerSelector, itemSelector) => {
        const container = document.querySelector(containerSelector);
        if (!(container instanceof HTMLElement)) return;

        let draggingItem = null;

        const items = () => Array.from(container.querySelectorAll(itemSelector)).filter((item) => item instanceof HTMLElement);

        items().forEach((item) => {
          item.setAttribute('draggable', 'true');
          item.classList.add('sortable-item');
        });

        container.addEventListener('dragstart', (event) => {
          const item = event.target.closest(itemSelector);
          if (!(item instanceof HTMLElement)) return;
          draggingItem = item;
          item.classList.add('dragging');
          event.dataTransfer.effectAllowed = 'move';
        });

        container.addEventListener('dragover', (event) => {
          if (!draggingItem) return;
          event.preventDefault();
          const target = event.target.closest(itemSelector);
          if (!(target instanceof HTMLElement) || target === draggingItem) return;
          target.classList.add('sortable-target');

          const rect = target.getBoundingClientRect();
          const insertBefore = event.clientY < rect.top + (rect.height / 2);
          container.insertBefore(draggingItem, insertBefore ? target : target.nextSibling);
        });

        container.addEventListener('dragleave', (event) => {
          const target = event.target.closest(itemSelector);
          if (!(target instanceof HTMLElement)) return;
          target.classList.remove('sortable-target');
        });

        container.addEventListener('drop', (event) => {
          if (!draggingItem) return;
          event.preventDefault();
          container.querySelectorAll('.sortable-target').forEach((node) => node.classList.remove('sortable-target'));
        });

        container.addEventListener('dragend', () => {
          if (draggingItem) draggingItem.classList.remove('dragging');
          container.querySelectorAll('.sortable-target').forEach((node) => node.classList.remove('sortable-target'));
          draggingItem = null;
        });
      };

      initializeResizableBlocks();
      initializeCollapsibleBlocks();
      initializeSortableGrid('.metric-grid', '.metric');
      initializeSortableGrid('.channel-grid', '.channel-card');

      const flowConfig = {
        viewBox: { width: 980, height: 300 },
        nodes: [
          { id: 'ui', title: 'Dashboard UI', subtitle: 'approval_ui/index.html', x: 30, y: 105, w: 180, h: 78, kind: 'control' },
          { id: 'gateway', title: 'Gateway', subtitle: '/api/agent/control', x: 250, y: 105, w: 180, h: 78, kind: 'core' },
          { id: 'anythingllm', title: 'AnythingLLM', subtitle: 'Developer API /chat', x: 470, y: 105, w: 180, h: 78, kind: 'brain' },
          { id: 'ollama', title: 'Ollama', subtitle: 'Model Provider', x: 700, y: 40, w: 180, h: 78, kind: 'integration' },
          { id: 'gptoss', title: 'gpt-oss:20b (LLM)', subtitle: 'Inference Runtime', x: 700, y: 180, w: 180, h: 78, kind: 'integration' },
        ],
        edges: [
          { from: 'ui', to: 'gateway', label: 'HTTP API: /api/agent/command', route: 'all' },
          { from: 'gateway', to: 'anythingllm', label: 'Path=anythingllm /workspace/:id/chat', route: 'anythingllm' },
          { from: 'anythingllm', to: 'ollama', label: 'AnythingLLM Provider API', route: 'anythingllm' },
          { from: 'gateway', to: 'ollama', label: 'Path=ollama /api/generate', route: 'ollama' },
          { from: 'ollama', to: 'gptoss', label: 'Local model runtime', route: 'all' },
        ],
      };

      const flowNodes = flowConfig.nodes.map((node) => ({ ...node }));
      let flowLastControlState = null;
      let flowDragState = null;
      let controlApiConnected = false;
      let channelsApiConnected = false;
      let cachedTasks = [];
      if (workflowDateInput && !workflowDateInput.value) {
        const now = new Date();
        workflowDateInput.value = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
      }
      let selectedInferencePath = 'anythingllm';
      let inferenceRoutesState = null;

      const toLocalTime = (iso) => {
        if (!iso) return '--:--:--';
        return new Date(iso).toLocaleTimeString('zh-Hant-TW', { hour12: false });
      };

      const scrollToBottom = (element) => {
        if (!(element instanceof HTMLElement)) return;
        element.scrollTop = element.scrollHeight;
      };

      const scrollConsoleToLatest = () => {
        [consoleLog, consoleLogLandscape].forEach((targetLog) => {
          if (!(targetLog instanceof HTMLElement)) return;
          scrollToBottom(targetLog);
          // çœŸæ­£å¯æ»¾å‹•çš„å®¹å™¨æœ‰æ™‚æ˜¯åŒ…ä½ <pre> çš„çˆ¶å±¤ï¼ˆä¾‹å¦‚æ”¶åˆå®¹å™¨ï¼‰ã€‚
          scrollToBottom(targetLog.parentElement);
          scrollToBottom(targetLog.closest('.collapsible-body'));
        });

        // å€å¡Šè¢«æ”¶åˆå¾Œå†å±•é–‹æ™‚ï¼Œéœ€ç­‰å¾…æ’ç‰ˆå®Œæˆæ‰å¯æ­£ç¢ºæ²å‹•åˆ°åº•ã€‚
        window.requestAnimationFrame(() => {
          [consoleLog, consoleLogLandscape].forEach((targetLog) => {
            if (!(targetLog instanceof HTMLElement)) return;
            scrollToBottom(targetLog);
            scrollToBottom(targetLog.parentElement);
            scrollToBottom(targetLog.closest('.collapsible-body'));
          });
        });
      };

      const appendLog = (text) => {
        [consoleLog, consoleLogLandscape].forEach((targetLog) => {
          targetLog.textContent += `\n${text}`;
        });
        scrollConsoleToLatest();
      };

      const appendChatLog = (speaker, text) => {
        chatLog.textContent += `\n[${speaker}] ${text}`;
        chatLog.scrollTop = chatLog.scrollHeight;
      };

      const pad2 = (value) => String(value).padStart(2, '0');
      const formatDuration = (totalMs) => {
        const totalSeconds = Math.max(0, Math.floor(totalMs / 1000));
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        return `${pad2(hours)}:${pad2(minutes)}:${pad2(seconds)}`;
      };

      let taskElapsedMs = 0;
      let taskRunStartedAtMs = null;
      let taskTimerId = null;
      let currentRunState = 'idle';

      const renderTaskElapsed = () => {
        if (!taskElapsed) return;
        const runningDelta = taskRunStartedAtMs ? (Date.now() - taskRunStartedAtMs) : 0;
        taskElapsed.textContent = formatDuration(taskElapsedMs + runningDelta);
      };

      const ensureTaskTimer = () => {
        if (taskTimerId) return;
        taskTimerId = window.setInterval(renderTaskElapsed, 1000);
      };

      const clearTaskTimer = () => {
        if (!taskTimerId) return;
        window.clearInterval(taskTimerId);
        taskTimerId = null;
      };

      const reconcileTaskElapsed = (nextState) => {
        if (nextState === 'idle' || nextState === 'stopped') {
          taskElapsedMs = 0;
          taskRunStartedAtMs = null;
          clearTaskTimer();
          renderTaskElapsed();
          currentRunState = nextState;
          return;
        }

        if (nextState === 'running') {
          if (currentRunState !== 'running') {
            taskRunStartedAtMs = Date.now();
          }
          ensureTaskTimer();
          renderTaskElapsed();
          currentRunState = nextState;
          return;
        }

        if (nextState === 'paused') {
          if (taskRunStartedAtMs) {
            taskElapsedMs += Date.now() - taskRunStartedAtMs;
            taskRunStartedAtMs = null;
          }
          clearTaskTimer();
          renderTaskElapsed();
          currentRunState = nextState;
        }
      };

      const clientToFlowPoint = (clientX, clientY) => {
        const rect = flowSvg.getBoundingClientRect();
        const scaleX = flowConfig.viewBox.width / rect.width;
        const scaleY = flowConfig.viewBox.height / rect.height;
        return {
          x: (clientX - rect.left) * scaleX,
          y: (clientY - rect.top) * scaleY,
        };
      };

      const startFlowDrag = (event) => {
        if (event.button !== 0 || !flowSvg) return;
        const nodeGroup = event.target.closest('[data-node-id]');
        if (!nodeGroup) return;

        const nodeId = nodeGroup.dataset.nodeId;
        const node = flowNodes.find((item) => item.id === nodeId);
        if (!node) return;

        const pointer = clientToFlowPoint(event.clientX, event.clientY);
        flowDragState = {
          node,
          pointerId: event.pointerId,
          offsetX: pointer.x - node.x,
          offsetY: pointer.y - node.y,
        };

        flowSvg.setPointerCapture(event.pointerId);
      };

      const moveFlowDrag = (event) => {
        if (!flowDragState || flowDragState.pointerId !== event.pointerId) return;

        const pointer = clientToFlowPoint(event.clientX, event.clientY);
        const { node, offsetX, offsetY } = flowDragState;
        node.x = clamp(pointer.x - offsetX, 10, flowConfig.viewBox.width - node.w - 10);
        node.y = clamp(pointer.y - offsetY, 10, flowConfig.viewBox.height - node.h - 10);

        renderFlow(flowLastControlState);
      };

      const endFlowDrag = (event) => {
        if (!flowDragState || flowDragState.pointerId !== event.pointerId) return;
        flowSvg.releasePointerCapture(event.pointerId);
        flowDragState = null;
      };

      flowSvg?.addEventListener('pointerdown', startFlowDrag);
      flowSvg?.addEventListener('pointermove', moveFlowDrag);
      flowSvg?.addEventListener('pointerup', endFlowDrag);
      flowSvg?.addEventListener('pointercancel', endFlowDrag);

      const renderFlow = (controlState) => {
        if (!flowSvg) return;
        flowLastControlState = controlState;

        const nodeMap = new Map(flowNodes.map((node) => [node.id, node]));
        const isActive = controlState?.state === 'running';
        const isPaused = controlState?.state === 'paused';

        const routeNodes = selectedInferencePath === 'ollama'
          ? ['gateway', 'ollama', 'gptoss']
          : ['gateway', 'anythingllm', 'ollama', 'gptoss'];
        const pausedNodes = selectedInferencePath === 'ollama' ? ['gateway', 'ollama'] : ['gateway', 'anythingllm'];

        const edgeMarkup = flowConfig.edges.map((edge) => {
          const from = nodeMap.get(edge.from);
          const to = nodeMap.get(edge.to);
          if (!from || !to) return '';

          const isRouteEdge = edge.route === 'all' || edge.route === selectedInferencePath;
          const edgeColor = isActive && isRouteEdge ? '#22d3ee' : (isPaused && isRouteEdge ? '#f59e0b' : '#64748b');
          const edgeOpacity = isRouteEdge ? 0.9 : 0.25;

          const startX = from.x + from.w;
          const startY = from.y + (from.h / 2);
          const endX = to.x;
          const endY = to.y + (to.h / 2);
          const bendX = (startX + endX) / 2;
          const path = `M ${startX} ${startY} C ${bendX} ${startY}, ${bendX} ${endY}, ${endX} ${endY}`;

          const labelX = bendX;
          const labelY = ((startY + endY) / 2) - 8;

          return `
            <path d="${path}" fill="none" stroke="${edgeColor}" stroke-width="3" marker-end="url(#arrowhead)" opacity="${edgeOpacity}" />
            <rect x="${labelX - 130}" y="${labelY - 11}" width="260" height="18" rx="9" fill="rgba(15,23,42,0.95)" stroke="rgba(148,163,184,0.35)" opacity="${isRouteEdge ? 1 : 0.45}" />
            <text x="${labelX}" y="${labelY + 2}" fill="#cbd5e1" font-size="11" text-anchor="middle" opacity="${isRouteEdge ? 1 : 0.45}">${edge.label}</text>
          `;
        }).join('');

        const nodeMarkup = flowNodes.map((node) => {
          const fillByKind = {
            integration: '#0f172a',
            core: '#0b253a',
            control: '#1e1b4b',
            brain: '#032d39',
          };

          const activeNode = isActive && routeNodes.includes(node.id);
          const pausedNode = isPaused && pausedNodes.includes(node.id);
          const stroke = activeNode ? '#22d3ee' : (pausedNode ? '#f59e0b' : '#64748b');
          const titleX = node.x + 12;
          const titleY = node.y + 28;

          return `
            <g data-node-id="${node.id}" style="cursor: grab;">
              <rect x="${node.x}" y="${node.y}" width="${node.w}" height="${node.h}" rx="12" fill="${fillByKind[node.kind] || '#0f172a'}" stroke="${stroke}" stroke-width="2.5" />
              <text x="${titleX}" y="${titleY}" fill="#e2e8f0" font-size="14" font-weight="700">${node.title}</text>
              <text x="${titleX}" y="${titleY + 20}" fill="#94a3b8" font-size="11">${node.subtitle}</text>
            </g>
          `;
        }).join('');

        flowSvg.innerHTML = `
          <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="8" refY="3.5" orient="auto">
              <polygon points="0 0, 10 3.5, 0 7" fill="#94a3b8"></polygon>
            </marker>
          </defs>
          <g>
            ${edgeMarkup}
            ${nodeMarkup}
          </g>
        `;
      };

      const setControlButtons = ({ start, pause, resume, stop }) => {
        button.disabled = !start;
        pauseBtn.disabled = !pause;
        resumeBtn.disabled = !resume;
        stopBtn.disabled = !stop;
      };

      const applyControlState = (data) => {
        reconcileTaskElapsed(data.state);
        assistantStatus.textContent = data.assistant_status;
        executionStatus.textContent = data.execution_status;
        taskProgress.textContent = `${data.task_progress}%`;
        lastUpdated.textContent = toLocalTime(data.last_updated_at);
        if (quickAgentSummary) {
          quickAgentSummary.textContent = JSON.stringify({
            agent_id: selectedAgentId,
            assistant_status: data.assistant_status,
            execution_status: data.execution_status,
            task_progress: data.task_progress,
            last_updated_at: data.last_updated_at,
          }, null, 2);
        }

        setControlButtons({
          start: Boolean(data.can?.start),
          pause: Boolean(data.can?.pause),
          resume: Boolean(data.can?.resume),
          stop: Boolean(data.can?.stop),
        });
        renderFlow(data);
      };

      const renderChannels = (channels) => {
        const mapping = {
          telegram: channelStateTelegram,
          line: channelStateLine,
          web_ui: channelStateWebUi,
        };

        Object.entries(mapping).forEach(([key, target]) => {
          const item = channels[key];
          if (!item) return;
          const enabledText = item.enabled ? 'ç›®å‰ï¼šå•Ÿç”¨' : 'ç›®å‰ï¼šåœç”¨';
          const connectionText = item.connected ? 'å·²é€£æ¥ï¼ˆæœ‰å¯¦éš›æµé‡ï¼‰' : 'æœªé€£æ¥ï¼ˆå°šç„¡æµé‡ï¼‰';
          const lastActivityText = item.last_activity_at ? `æœ€å¾Œæ´»å‹•ï¼š${toLocalTime(item.last_activity_at)}` : 'æœ€å¾Œæ´»å‹•ï¼š--';
          target.textContent = `${enabledText}ï½œç‹€æ…‹ï¼š${connectionText}ï½œ${lastActivityText}`;
          target.style.color = item.enabled ? (item.connected ? '#67e8f9' : '#fde68a') : '#fda4af';
          const button = document.querySelector(`[data-channel-toggle="${key}"]`);
          if (button) {
            button.dataset.enabled = item.enabled ? 'true' : 'false';
            button.textContent = item.enabled ? 'é—œé–‰' : 'é–‹å•Ÿ';
            button.disabled = false;
          }
        });
      };

      const renderChannelsDisconnected = (message = 'Gateway é€šé“ API æœªé€£æ¥') => {
        const mapping = {
          telegram: channelStateTelegram,
          line: channelStateLine,
          web_ui: channelStateWebUi,
        };

        Object.values(mapping).forEach((target) => {
          target.textContent = `æœªé€£æ¥ï¼ˆ${message}ï¼‰`;
          target.style.color = '#fda4af';
        });

        channelToggleButtons.forEach((buttonEl) => {
          buttonEl.textContent = 'é‡è©¦';
          buttonEl.disabled = false;
          delete buttonEl.dataset.enabled;
        });
      };

      const renderAgentInfo = () => {
        const current = cachedAgents.find((item) => item.id === selectedAgentId) || cachedAgents[0];
        if (agentInfo) {
          if (!current) {
            agentInfo.textContent = '[agent] å°šç„¡ Agent';
          } else {
            agentInfo.textContent = JSON.stringify(current, null, 2);
          }
        }
      };

      const refreshAgentCommunication = async () => {
        const response = await fetch('/api/agent/communications');
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'è®€å– Agent é€šä¿¡åœ–å¤±æ•—');
        }
        if (agentCommInfo) {
          agentCommInfo.textContent = JSON.stringify(payload.data || [], null, 2);
        }
      };

      const refreshAgents = async ({ keepSelection = true } = {}) => {
        const response = await fetch('/api/agents');
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'è®€å– Agent åˆ—è¡¨å¤±æ•—');
        }

        cachedAgents = Array.isArray(payload.data) ? payload.data : [];
        if (!selectedAgentId || !keepSelection || !cachedAgents.some((item) => item.id === selectedAgentId)) {
          selectedAgentId = cachedAgents[0]?.id || null;
        }

        if (agentSelect) {
          agentSelect.innerHTML = cachedAgents.map((item) => `<option value="${item.id}">${item.name} (${item.model})${item.is_primary ? ' [primary]' : ''}</option>`).join('');
          if (selectedAgentId) agentSelect.value = selectedAgentId;
        }

        renderAgentInfo();
        await refreshAgentCommunication();
        return cachedAgents;
      };

      const taskStatusPriority = {
        running: 6,
        pending: 5,
        retry_scheduled: 4,
        failed: 3,
        cancelled: 2,
        succeeded: 1,
      };

      const sortTasks = (tasks, sortKey) => {
        const list = [...tasks];
        if (sortKey === 'created_asc') return list.sort((a, b) => a.created_at.localeCompare(b.created_at));
        if (sortKey === 'updated_desc') return list.sort((a, b) => b.updated_at.localeCompare(a.updated_at));
        if (sortKey === 'priority_desc') return list.sort((a, b) => (b.priority - a.priority) || ((taskStatusPriority[b.status] || 0) - (taskStatusPriority[a.status] || 0)));
        return list.sort((a, b) => b.created_at.localeCompare(a.created_at));
      };

      const renderTaskList = (tasks) => {
        if (!taskList) return;
        if (!tasks.length) {
          taskList.innerHTML = '<div class="task-empty">ç›®å‰æ²’æœ‰ä»»å‹™ã€‚</div>';
          return;
        }

        taskList.innerHTML = tasks.map((task) => {
          const canDelete = ['succeeded', 'failed', 'cancelled'].includes(task.status);
          return `
            <article class="task-item">
              <div class="task-item-head">
                <span class="task-name">${task.name}</span>
                <span class="task-meta">${task.status}</span>
              </div>
              <div class="task-meta">id: ${task.id}</div>
              <div class="task-meta">agent: ${task.agent_id || '-'}ï½œpriority: ${task.priority}ï½œå»ºç«‹ï¼š${toLocalTime(task.created_at)}ï½œæ›´æ–°ï¼š${toLocalTime(task.updated_at)}</div>
              <div class="task-actions">
                <button class="task-btn delete" data-task-delete="${task.id}" type="button" ${canDelete ? '' : 'disabled'}>åˆªé™¤</button>
              </div>
            </article>
          `;
        }).join('');
      };

      const refreshTasks = async () => {
        const response = await fetch(`/api/tasks${selectedAgentId ? `?agent_id=${encodeURIComponent(selectedAgentId)}` : ''}`);
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'è®€å–ä»»å‹™åˆ—è¡¨å¤±æ•—');
        }
        cachedTasks = Array.isArray(payload.data) ? payload.data : [];
        renderTaskList(sortTasks(cachedTasks, taskSort?.value || 'created_desc'));
      };

      const deleteTaskById = async (taskId) => {
        const response = await fetch(`/api/tasks/${taskId}`, { method: 'DELETE' });
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'åˆªé™¤ä»»å‹™å¤±æ•—');
        }
      };

      const refreshMemoryFiles = async () => {
        const response = await fetch('/api/memory/files');
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'è®€å–è¨˜æ†¶æª”æ¡ˆåˆ—è¡¨å¤±æ•—');
        }

        const files = Array.isArray(payload.data) ? payload.data : [];
        if (memoryFileSelect) {
          memoryFileSelect.innerHTML = files.map((file) => `<option value="${file.path}">${file.path}</option>`).join('');
          if (!files.length) {
            memoryFileSelect.innerHTML = '<option value="">(æ²’æœ‰å¯ç”¨è¨˜æ†¶æª”)</option>';
          }
        }
        return files;
      };

      const openMemoryFile = async (targetPath) => {
        if (!targetPath) throw new Error('è«‹å…ˆé¸æ“‡è¨˜æ†¶æª”æ¡ˆ');
        const response = await fetch(`/api/memory/file?path=${encodeURIComponent(targetPath)}`);
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'é–‹å•Ÿè¨˜æ†¶æª”æ¡ˆå¤±æ•—');
        }
        const content = payload.data?.content || '';
        const truncated = payload.data?.truncated;
        if (memoryFileContent) {
          memoryFileContent.textContent = truncated
            ? `${content}

[memory] å…§å®¹éé•·ï¼Œå·²æˆªæ–·é¡¯ç¤ºã€‚`
            : content;
        }
        return payload.data;
      };

      const runMemoryWorkflow = async ({ job, date, dryRun }) => {
        const response = await fetch('/api/memory/workflows/run', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ job, date, dryRun }),
        });
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'åŸ·è¡Œè¨˜æ†¶æµç¨‹å¤±æ•—');
        }
        if (workflowResult) {
          workflowResult.textContent = JSON.stringify(payload.data, null, 2);
        }
        return payload.data;
      };

      const refreshChannels = async () => {
        const response = await fetch('/api/channels');
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'è®€å–æ¥å£ç‹€æ…‹å¤±æ•—');
        }
        channelsApiConnected = true;
        renderChannels(payload.data);
      };

      const toggleChannel = async (channel, enabled) => {
        const response = await fetch('/api/channels', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ channel, enabled }),
        });
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'åˆ‡æ›æ¥å£å¤±æ•—');
        }
        channelsApiConnected = true;
        renderChannels(payload.data);
      };

      const refreshState = async () => {
        const response = await fetch(`/api/agent/control${selectedAgentId ? `?agent_id=${encodeURIComponent(selectedAgentId)}` : ''}`);
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'è®€å– Agent ç‹€æ…‹å¤±æ•—');
        }
        controlApiConnected = true;
        applyControlState(payload.data);
      };
      const applyInferenceRouteUiState = (routes) => {
        const anythingRoute = routes?.anythingllm;
        const ollamaRoute = routes?.ollama;
        const anythingEnabled = Boolean(anythingRoute?.enabled);
        const ollamaEnabled = Boolean(ollamaRoute?.enabled);

        if (chatPath) {
          const anythingOption = chatPath.querySelector('option[value="anythingllm"]');
          const ollamaOption = chatPath.querySelector('option[value="ollama"]');

          if (anythingOption) {
            anythingOption.disabled = !anythingEnabled;
            anythingOption.textContent = anythingEnabled
              ? 'ç¶“ AnythingLLMï¼ˆé è¨­ï¼‰'
              : `ç¶“ AnythingLLMï¼ˆä¸å¯ç”¨ï¼š${anythingRoute?.reason || 'æœªè¨­å®š'}ï¼‰`;
          }
          if (ollamaOption) {
            ollamaOption.disabled = !ollamaEnabled;
            const reason = ollamaRoute?.reason ? `ï¼ˆä¸å¯ç”¨ï¼š${ollamaRoute.reason}ï¼‰` : '';
            ollamaOption.textContent = ollamaEnabled
              ? `ç›´é€£ Ollamaï¼ˆ${ollamaRoute?.model || 'gpt-oss'}ï¼‰`
              : `ç›´é€£ Ollama${reason}`;
          }

          if (!anythingEnabled && ollamaEnabled) {
            chatPath.value = 'ollama';
            selectedInferencePath = 'ollama';
          }
        }

        const hasAnyRoute = anythingEnabled || ollamaEnabled;
        if (chatInput) chatInput.disabled = !hasAnyRoute;
        if (chatSend) chatSend.disabled = !hasAnyRoute;

        if (inferenceRouteStatus) {
          if (!hasAnyRoute) {
            inferenceRouteStatus.textContent = 'ç›®å‰æ²’æœ‰å¯ç”¨æ¨è«–è·¯å¾‘ï¼Œè«‹æª¢æŸ¥ AnythingLLM API Key æˆ– Ollama æœå‹™ã€‚';
            inferenceRouteStatus.style.color = '#fda4af';
          } else if (selectedInferencePath === 'anythingllm') {
            inferenceRouteStatus.textContent = 'ç›®å‰è·¯å¾‘ï¼šAnythingLLMï¼ˆç”± Gateway è½‰é€ï¼‰';
            inferenceRouteStatus.style.color = '#67e8f9';
          } else {
            inferenceRouteStatus.textContent = `ç›®å‰è·¯å¾‘ï¼šOllama ç›´é€£ï¼ˆ${ollamaRoute?.model || 'gpt-oss'}ï¼‰`;
            inferenceRouteStatus.style.color = '#86efac';
          }
        }
      };

      const refreshInferenceRoutes = async () => {
        const response = await fetch('/api/inference/routes');
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'è®€å–æ¨è«–è·¯å¾‘å¤±æ•—');
        }
        inferenceRoutesState = payload.data?.routes || null;
        applyInferenceRouteUiState(inferenceRoutesState);
      };

      const sendControl = async (action) => {
        const response = await fetch('/api/agent/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action, agent_id: selectedAgentId }),
        });
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || `${action} å¤±æ•—`);
        }
        applyControlState(payload.data);
        return payload.data;
      };

      const sendCommand = async (text, path) => {
        const response = await fetch('/api/agent/command', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text, path, agent_id: selectedAgentId }),
        });
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'ç™¼é€æŒ‡ä»¤å¤±æ•—');
        }
        return payload;
      };

      button.addEventListener('click', async () => {
        try {
          status.textContent = 'Agent å•Ÿå‹•ä¸­...';
          await sendControl('start');
          status.textContent = 'Agent å·²å•Ÿå‹•ï¼Œç§˜æ›¸å¾…å‘½ä¸­ã€‚';
          appendLog('[control] ä½¿ç”¨è€…å•Ÿå‹• Agent');
        } catch (error) {
          status.textContent = `å•Ÿå‹•å¤±æ•—ï¼š${error.message}`;
          appendLog(`[error] å•Ÿå‹•å¤±æ•—ï¼š${error.message}`);
        }
      });

      pauseBtn.addEventListener('click', async () => {
        try {
          await sendControl('pause');
          status.textContent = 'Agent å·²æš«åœã€‚';
          appendLog('[control] ä½¿ç”¨è€…æš«åœä»»å‹™');
        } catch (error) {
          status.textContent = `æš«åœå¤±æ•—ï¼š${error.message}`;
          appendLog(`[error] æš«åœå¤±æ•—ï¼š${error.message}`);
        }
      });

      resumeBtn.addEventListener('click', async () => {
        try {
          await sendControl('resume');
          status.textContent = 'Agent å·²æ¢å¾©åŸ·è¡Œã€‚';
          appendLog('[control] ä½¿ç”¨è€…æ¢å¾©ä»»å‹™');
        } catch (error) {
          status.textContent = `æ¢å¾©å¤±æ•—ï¼š${error.message}`;
          appendLog(`[error] æ¢å¾©å¤±æ•—ï¼š${error.message}`);
        }
      });

      stopBtn.addEventListener('click', async () => {
        try {
          await sendControl('stop');
          status.textContent = 'Agent å·²åœæ­¢ã€‚';
          appendLog('[control] ä½¿ç”¨è€…åœæ­¢ Agent');
        } catch (error) {
          status.textContent = `åœæ­¢å¤±æ•—ï¼š${error.message}`;
          appendLog(`[error] åœæ­¢å¤±æ•—ï¼š${error.message}`);
        }
      });



      if (agentSelect) {
        agentSelect.addEventListener('change', async () => {
          selectedAgentId = agentSelect.value || null;
          renderAgentInfo();
          await refreshState();
          await refreshTasks();
          appendLog(`[agent] å·²åˆ‡æ› Agentï¼š${selectedAgentId || 'default'}`);
        });
      }

      if (refreshAgentsBtn) {
        refreshAgentsBtn.addEventListener('click', async () => {
          try {
            await refreshAgents();
            await refreshState();
            await refreshTasks();
            appendLog('[agent] Agent åˆ—è¡¨å·²æ›´æ–°');
          } catch (error) {
            status.textContent = `Agent åˆ—è¡¨æ›´æ–°å¤±æ•—ï¼š${error.message}`;
            appendLog(`[error] Agent åˆ—è¡¨æ›´æ–°å¤±æ•—ï¼š${error.message}`);
          }
        });
      }

      if (createAgentBtn) {
        createAgentBtn.addEventListener('click', async () => {
          const name = newAgentName?.value?.trim();
          if (!name) {
            status.textContent = 'è«‹è¼¸å…¥ Agent åç¨±';
            return;
          }
          const model = newAgentModel?.value?.trim() || 'gpt-oss:20b';
          const soul = newAgentSoul?.value?.trim() || 'operations';
          const communication_mode = newAgentComm?.value === 'direct' ? 'direct' : 'hub_and_spoke';
          try {
            const response = await fetch('/api/agents', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ name, model, soul, communication_mode }),
            });
            const payload = await response.json();
            if (!response.ok || !payload.ok) throw new Error(payload.error || 'æ–°å¢ Agent å¤±æ•—');
            selectedAgentId = payload.data?.id || selectedAgentId;
            if (newAgentName) newAgentName.value = '';
            if (newAgentModel) newAgentModel.value = '';
            if (newAgentSoul) newAgentSoul.value = '';
            await refreshAgents({ keepSelection: true });
            await refreshState();
            await refreshTasks();
            appendLog(`[agent] å·²æ–°å¢ Agentï¼š${payload.data?.name || name}`);
          } catch (error) {
            status.textContent = `æ–°å¢ Agent å¤±æ•—ï¼š${error.message}`;
            appendLog(`[error] æ–°å¢ Agent å¤±æ•—ï¼š${error.message}`);
          }
        });
      }


      if (chatPath) {
        chatPath.addEventListener('change', () => {
          selectedInferencePath = chatPath.value === 'ollama' ? 'ollama' : 'anythingllm';
          applyInferenceRouteUiState(inferenceRoutesState);
          renderFlow(flowLastControlState);
        });
      }

      chatForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        const text = chatInput.value.trim();
        if (!text) return;
        const path = chatPath?.value === 'ollama' ? 'ollama' : 'anythingllm';
        selectedInferencePath = path;
        renderFlow(flowLastControlState);

        chatInput.disabled = true;
        if (chatPath) chatPath.disabled = true;
        appendChatLog('user', `[${path}] ${text}`);
        appendLog(`[command] UI æŒ‡ä»¤é€å‡ºï¼ˆ${path}ï¼‰ï¼š${text}`);

        try {
          const payload = await sendCommand(text, path);
          selectedInferencePath = payload.path || path;
          applyInferenceRouteUiState(inferenceRoutesState);
          renderFlow(flowLastControlState);
          const reply = payload.reply;
          appendChatLog('agent', `${payload.agent?.agent_name || 'agent'}: ${reply}`);
          status.textContent = `å·²æ”¶åˆ°å›è¦†ï¼ˆ${payload.path || path}ï¼‰ã€‚`;
          appendLog(`[command] æŒ‡ä»¤å®Œæˆï¼ˆ${payload.path || path}${payload.model ? ` / ${payload.model}` : ''}ï¼‰`);
        } catch (error) {
          const extraHint = selectedInferencePath === 'ollama' ? 'ï¼ˆè«‹ç¢ºèª Ollama æ­£åœ¨åŸ·è¡Œï¼‰' : 'ï¼ˆè«‹ç¢ºèª AnythingLLM API Key/æœå‹™ï¼‰';
          appendChatLog('error', `${error.message} ${extraHint}`);
          status.textContent = `æŒ‡ä»¤å¤±æ•—ï¼š${error.message}`;
          appendLog(`[error] æŒ‡ä»¤å¤±æ•—ï¼š${error.message}`);
        } finally {
          chatInput.disabled = false;
          if (chatPath) chatPath.disabled = false;
          chatInput.value = '';
          chatInput.focus();
        }
      });

      channelToggleButtons.forEach((buttonEl) => {
        buttonEl.addEventListener('click', async () => {
          const channel = buttonEl.dataset.channelToggle;
          buttonEl.disabled = true;
          try {
            if (!channelsApiConnected) {
              status.textContent = 'é‡æ–°å˜—è©¦é€£æ¥é€šé“ç‹€æ…‹...';
              await refreshChannels();
              status.textContent = 'é€šé“ç‹€æ…‹ API å·²é€£ç·šã€‚';
              appendLog('[channel] å·²é‡æ–°é€£æ¥é€šé“ç‹€æ…‹ API');
              return;
            }

            const isEnabled = buttonEl.dataset.enabled === 'true';
            const nextEnabled = !isEnabled;
            await toggleChannel(channel, nextEnabled);
            appendLog(`[channel] ${channel} å·²${nextEnabled ? 'é–‹å•Ÿ' : 'é—œé–‰'}`);
          } catch (error) {
            channelsApiConnected = false;
            renderChannelsDisconnected('è«‹æŒ‰é‡è©¦é‡æ–°é€£ç·š');
            status.textContent = `æ¥å£åˆ‡æ›å¤±æ•—ï¼š${error.message}`;
            appendLog(`[error] æ¥å£åˆ‡æ›å¤±æ•—ï¼š${error.message}`);
          } finally {
            buttonEl.disabled = false;
          }
        });
      });

      if (taskSort) {
        taskSort.addEventListener('change', () => {
          renderTaskList(sortTasks(cachedTasks, taskSort.value));
        });
      }

      if (refreshTasksBtn) {
        refreshTasksBtn.addEventListener('click', async () => {
          try {
            await refreshTasks();
            appendLog('[task] ä»»å‹™åˆ—è¡¨å·²æ›´æ–°');
          } catch (error) {
            status.textContent = `ä»»å‹™åˆ—è¡¨æ›´æ–°å¤±æ•—ï¼š${error.message}`;
            appendLog(`[error] ä»»å‹™åˆ—è¡¨æ›´æ–°å¤±æ•—ï¼š${error.message}`);
          }
        });
      }

      if (refreshMemoryFilesBtn) {
        refreshMemoryFilesBtn.addEventListener('click', async () => {
          try {
            await refreshMemoryFiles();
            appendLog('[memory] è¨˜æ†¶æª”æ¡ˆåˆ—è¡¨å·²æ›´æ–°');
          } catch (error) {
            status.textContent = `è¨˜æ†¶æª”æ¡ˆåˆ—è¡¨æ›´æ–°å¤±æ•—ï¼š${error.message}`;
            appendLog(`[error] è¨˜æ†¶æª”æ¡ˆåˆ—è¡¨æ›´æ–°å¤±æ•—ï¼š${error.message}`);
          }
        });
      }

      if (openMemoryFileBtn) {
        openMemoryFileBtn.addEventListener('click', async () => {
          try {
            const path = memoryFileSelect?.value || '';
            const file = await openMemoryFile(path);
            appendLog(`[memory] å·²é–‹å•Ÿ ${file.path}`);
          } catch (error) {
            status.textContent = `é–‹å•Ÿè¨˜æ†¶æª”æ¡ˆå¤±æ•—ï¼š${error.message}`;
            appendLog(`[error] é–‹å•Ÿè¨˜æ†¶æª”æ¡ˆå¤±æ•—ï¼š${error.message}`);
          }
        });
      }

      if (runWorkflowBtn) {
        runWorkflowBtn.addEventListener('click', async () => {
          try {
            const job = workflowJobSelect?.value || 'microsync';
            const date = workflowDateInput?.value || '';
            const dryRun = Boolean(workflowDryRun?.checked);
            const result = await runMemoryWorkflow({ job, date, dryRun });
            appendLog(`[workflow] ${job} åŸ·è¡Œå®Œæˆ`);
            status.textContent = `æµç¨‹åŸ·è¡Œå®Œæˆï¼š${job}`;
            if (job === 'microsync' || job === 'weekly-compound') {
              await refreshMemoryFiles();
            }
          } catch (error) {
            status.textContent = `æµç¨‹åŸ·è¡Œå¤±æ•—ï¼š${error.message}`;
            appendLog(`[error] æµç¨‹åŸ·è¡Œå¤±æ•—ï¼š${error.message}`);
          }
        });
      }

      if (taskList) {
        taskList.addEventListener('click', async (event) => {
          const target = event.target;
          if (!(target instanceof HTMLElement)) return;
          const taskId = target.dataset.taskDelete;
          if (!taskId) return;
          target.setAttribute('disabled', 'true');
          try {
            await deleteTaskById(taskId);
            appendLog(`[task] å·²åˆªé™¤ä»»å‹™ ${taskId}`);
            await refreshTasks();
          } catch (error) {
            status.textContent = `åˆªé™¤ä»»å‹™å¤±æ•—ï¼š${error.message}`;
            appendLog(`[error] åˆªé™¤ä»»å‹™å¤±æ•—ï¼š${error.message}`);
            target.removeAttribute('disabled');
          }
        });
      }

      clearConsoleBtn.addEventListener('click', () => {
        [consoleLog, consoleLogLandscape].forEach((targetLog) => {
          targetLog.textContent = '[system] console å·²æ¸…ç©º';
        });
        scrollConsoleToLatest();
        lastUpdated.textContent = toLocalTime(new Date().toISOString());
      });

      document.addEventListener('click', (event) => {
        if (!(event.target instanceof HTMLElement) || !event.target.classList.contains('collapsible-trigger')) return;
        const parentBlock = event.target.closest('[aria-label="console"]');
        if (!parentBlock) return;
        window.requestAnimationFrame(scrollConsoleToLatest);
      });


      const clamp = (value, min, max) => Math.max(min, Math.min(value, max));

      const setupResizer = ({ handle, onStart, onMove, onEnd, cursor }) => {
        if (!handle) return;

        handle.addEventListener('mousedown', (event) => {
          event.preventDefault();
          const startState = onStart(event);
          if (!startState) return;
          document.body.style.cursor = cursor;
          document.body.style.userSelect = 'none';

          const onMouseMove = (moveEvent) => onMove(moveEvent, startState);
          const onMouseUp = () => {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            if (onEnd) onEnd();
          };

          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });
      };

      setupResizer({
        handle: resizerTop,
        cursor: 'row-resize',
        onStart: () => {
          const rect = panelEl.getBoundingClientRect();
          const styles = getComputedStyle(document.documentElement);
          return {
            panelTop: rect.top,
            panelHeight: rect.height,
            currentR2: parseFloat(styles.getPropertyValue('--panel-r2')) || 20,
            currentR3: parseFloat(styles.getPropertyValue('--panel-r3')) || 20,
          };
        },
        onMove: (event, state) => {
          if (window.matchMedia('(orientation: landscape)').matches) {
            const rect = panelEl.getBoundingClientRect();
            const minLeft = 320;
            const minRight = 320;
            const leftPx = clamp(event.clientX - rect.left, minLeft, rect.width - minRight);
            const leftPct = (leftPx / rect.width) * 100;
            document.documentElement.style.setProperty('--panel-c1', `${leftPct}fr`);
            document.documentElement.style.setProperty('--panel-c2', `${100 - leftPct}fr`);
            return;
          }

          const minTop = 180;
          const minMid = 140;
          const minBottom = 120;
          const y = event.clientY - state.panelTop;
          const maxTop = state.panelHeight - (minMid + minBottom);
          const topPx = clamp(y, minTop, maxTop);
          const remain = state.panelHeight - topPx;
          const midRatio = state.currentR2 / (state.currentR2 + state.currentR3);
          const midPx = clamp(remain * midRatio, minMid, remain - minBottom);
          const bottomPx = remain - midPx;

          document.documentElement.style.setProperty('--panel-r1', `${topPx}fr`);
          document.documentElement.style.setProperty('--panel-r2', `${midPx}fr`);
          document.documentElement.style.setProperty('--panel-r3', `${bottomPx}fr`);
        },
      });

      setupResizer({
        handle: resizerBottom,
        cursor: 'row-resize',
        onStart: () => {
          const rect = panelEl.getBoundingClientRect();
          const styles = getComputedStyle(document.documentElement);
          return {
            panelTop: rect.top,
            panelHeight: rect.height,
            currentR1: parseFloat(styles.getPropertyValue('--panel-r1')) || 60,
            currentR2: parseFloat(styles.getPropertyValue('--panel-r2')) || 20,
            currentR3: parseFloat(styles.getPropertyValue('--panel-r3')) || 20,
          };
        },
        onMove: (event, state) => {
          if (window.matchMedia('(orientation: landscape)').matches) return;

          const minTop = 180;
          const minMid = 140;
          const minBottom = 120;
          const y = event.clientY - state.panelTop;
          const total = state.currentR1 + state.currentR2 + state.currentR3;
          const topPx = clamp((state.panelHeight * (state.currentR1 / total)), minTop, state.panelHeight - (minMid + minBottom));
          const maxY = state.panelHeight - minBottom;
          const boundaryPx = clamp(y, topPx + minMid, maxY);
          const midPx = boundaryPx - topPx;
          const bottomPx = state.panelHeight - boundaryPx;

          document.documentElement.style.setProperty('--panel-r2', `${midPx}fr`);
          document.documentElement.style.setProperty('--panel-r3', `${bottomPx}fr`);
        },
      });

      setupResizer({
        handle: stageResizer,
        cursor: 'row-resize',
        onStart: () => {
          const rect = stageShellEl?.getBoundingClientRect();
          if (!rect) return null;
          return { stageTop: rect.top, stageHeight: rect.height };
        },
        onMove: (event, state) => {
          const minStage = 180;
          const minChat = 140;
          const topPx = clamp(event.clientY - state.stageTop, minStage, state.stageHeight - minChat);
          document.documentElement.style.setProperty('--stage-r1', `${topPx}fr`);
          document.documentElement.style.setProperty('--stage-r2', `${state.stageHeight - topPx}fr`);
        },
      });

      setupResizer({
        handle: dashboardResizer,
        cursor: 'row-resize',
        onStart: () => {
          const rect = dashboardEl.getBoundingClientRect();
          return { dashboardTop: rect.top, dashboardHeight: rect.height };
        },
        onMove: (event, state) => {
          if (!window.matchMedia('(orientation: landscape)').matches) return;
          const minMain = 180;
          const minConsole = 140;
          const y = clamp(event.clientY - state.dashboardTop, minMain, state.dashboardHeight - minConsole);
          document.documentElement.style.setProperty('--dash-r1', `${y}fr`);
          document.documentElement.style.setProperty('--dash-r2', `${state.dashboardHeight - y}fr`);
        },
      });

      quickStartAgent?.addEventListener('click', () => button.click());
      quickPauseAgent?.addEventListener('click', () => pauseBtn.click());
      quickResumeAgent?.addEventListener('click', () => resumeBtn.click());
      quickStopAgent?.addEventListener('click', () => stopBtn.click());

      Promise.all([refreshAgents({ keepSelection: false }), refreshChannels(), refreshInferenceRoutes(), refreshMemoryFiles()])
        .then(async () => {
          controlApiConnected = true;
          channelsApiConnected = true;
          status.textContent = 'å·²é€£ç·š Gateway æ§åˆ¶ API';
          appendLog('[system] å·²é€£ç·š Gateway æ§åˆ¶ API');
          await refreshState();
          await refreshTasks();
          const selected = memoryFileSelect?.value || '';
          if (selected) {
            await openMemoryFile(selected);
          }
        })
        .catch((error) => {
          controlApiConnected = false;
          channelsApiConnected = false;
          setControlButtons({ start: false, pause: false, resume: false, stop: false });
          status.textContent = `ç„¡æ³•é€£ç·šæ§åˆ¶ APIï¼š${error.message}`;
          appendLog(`[error] ç„¡æ³•é€£ç·šæ§åˆ¶ APIï¼š${error.message}`);
          renderChannelsDisconnected('åˆå§‹é€£ç·šå¤±æ•—');
          renderFlow();
        });

      renderChannelsDisconnected('å°šæœªé€£ç·š');
      renderFlow();
    </script>
  </body>
</html>
