<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Agent Launch UI</title>
    <style>
      :root {
        --bg-1: #0f172a;
        --bg-2: #1e293b;
        --card: rgba(15, 23, 42, 0.75);
        --text: #e2e8f0;
        --primary: #38bdf8;
        --accent: #f472b6;
        --panel-r1: 60fr;
        --panel-r2: 20fr;
        --panel-r3: 20fr;
        --panel-c1: 1fr;
        --panel-c2: 1fr;
        --dash-r1: 60fr;
        --dash-r2: 40fr;
        --stage-r1: 74fr;
        --stage-r2: 26fr;
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Noto Sans TC", "Microsoft JhengHei", sans-serif;
        color: var(--text);
        background: radial-gradient(circle at top right, #334155, var(--bg-1) 45%),
          linear-gradient(135deg, var(--bg-1), var(--bg-2));
      }

      .panel {
        width: 100vw;
        height: 100vh;
        padding: 1rem;
        background: var(--card);
        border: 1px solid rgba(148, 163, 184, 0.2);
        backdrop-filter: blur(10px);
        display: grid;
        grid-template-rows: minmax(180px, var(--panel-r1)) 10px minmax(140px, var(--panel-r2)) 10px minmax(120px, var(--panel-r3));
        gap: 0.6rem;
      }


      .resizer {
        border-radius: 999px;
        background: rgba(56, 189, 248, 0.32);
        border: 1px solid rgba(125, 211, 252, 0.55);
        cursor: row-resize;
        position: relative;
      }

      .resizer::after {
        content: '';
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 58px;
        height: 3px;
        border-radius: 999px;
        background: rgba(186, 230, 253, 0.95);
      }

      .resizer:focus-visible {
        outline: 2px solid #22d3ee;
        outline-offset: 2px;
      }

      .panel-resizer-top { grid-row: 2; }
      .panel-resizer-bottom { grid-row: 4; }

      .dashboard h1 {
        margin: 0;
        font-size: clamp(1.1rem, 2.4vw, 1.5rem);
      }

      .dashboard p {
        line-height: 1.5;
        color: #cbd5e1;
        margin: 0.55rem 0 0.8rem;
        font-size: 0.9rem;
      }

      .dashboard-main {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 0.65rem 1rem;
      }

      .dashboard-intro {
        flex: 1 1 320px;
        min-width: 0;
      }

      .dashboard-intro p {
        margin-bottom: 0;
      }

      .dashboard-actions {
        display: flex;
        align-items: center;
        gap: 0.65rem;
        flex-wrap: wrap;
      }

      .start-btn {
        border: 0;
        border-radius: 999px;
        font-size: 0.95rem;
        font-weight: 700;
        letter-spacing: 0.02em;
        padding: 0.65rem 1.35rem;
        cursor: pointer;
        color: #0f172a;
        background: linear-gradient(135deg, var(--primary), #22d3ee);
        box-shadow: 0 12px 22px rgba(34, 211, 238, 0.35);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .start-btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 16px 26px rgba(34, 211, 238, 0.45);
      }

      .stage {
        position: relative;
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 20px;
        background: rgba(15, 23, 42, 0.45);
        overflow: hidden;
      }

      .stage-shell {
        display: grid;
        grid-template-rows: minmax(180px, var(--stage-r1)) 10px minmax(140px, var(--stage-r2));
        gap: 0.6rem;
      }

      .stage-shell-resizer {
        grid-row: 2;
        cursor: row-resize;
      }

      .stage-chat {
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.62);
        padding: 0.7rem;
        display: flex;
        flex-direction: column;
        gap: 0.55rem;
      }

      .chat-log {
        margin: 0;
        flex: 1;
        min-height: 88px;
        overflow: auto;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        font-size: 0.75rem;
        color: #bfdbfe;
        white-space: pre-wrap;
      }

      .chat-form {
        display: grid;
        grid-template-columns: minmax(0, 1fr) auto;
        gap: 0.5rem;
      }

      .chat-input {
        width: 100%;
        border: 1px solid rgba(125, 211, 252, 0.45);
        border-radius: 10px;
        background: rgba(15, 23, 42, 0.72);
        color: #e2e8f0;
        padding: 0.55rem 0.65rem;
        font-size: 0.84rem;
      }

      .chat-send {
        border: 1px solid rgba(125, 211, 252, 0.45);
        border-radius: 10px;
        background: rgba(15, 23, 42, 0.82);
        color: #bae6fd;
        font-weight: 700;
        padding: 0.5rem 0.85rem;
        cursor: pointer;
      }

      .stage canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      .stage-controls {
        position: absolute;
        top: 1.05rem;
        left: 0.65rem;
        right: 0.65rem;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: 0.5rem;
        flex-wrap: wrap;
        z-index: 2;
      }

      .upload-label {
        border: 1px solid rgba(125, 211, 252, 0.45);
        background: rgba(15, 23, 42, 0.72);
        border-radius: 8px;
        padding: 0.32rem 0.55rem;
        font-size: 0.74rem;
        color: #bfdbfe;
        cursor: pointer;
      }

      .upload-label input {
        display: none;
      }

      .motion-btn {
        border: 1px solid rgba(125, 211, 252, 0.45);
        background: rgba(15, 23, 42, 0.72);
        color: #bae6fd;
        border-radius: 8px;
        padding: 0.32rem 0.55rem;
        font-size: 0.74rem;
        cursor: pointer;
      }

      .status {
        margin: 0;
        font-size: 0.95rem;
        color: #a5f3fc;
        min-height: 1.2em;
      }

      .dashboard,
      .console {
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.6);
        padding: 0.8rem;
        overflow: hidden;
      }

      .console,
      .console-landscape {
        display: flex;
        flex-direction: column;
        min-height: 0;
      }

      .monitor {
        margin-top: 0.6rem;
        display: grid;
        gap: 0.62rem;
      }

      .pane {
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 14px;
        background: rgba(15, 23, 42, 0.6);
        padding: 0.75rem;
      }

      .resizable-block {
        resize: both;
        overflow: auto;
        min-width: 220px;
        min-height: 120px;
        max-width: 100%;
      }

      .resizable-block.compact {
        min-width: 150px;
        min-height: 72px;
      }

      .resizable-block::-webkit-resizer {
        background: linear-gradient(135deg, transparent 0 45%, rgba(103, 232, 249, 0.85) 45% 55%, transparent 55% 100%);
      }

      .collapsible-block {
        display: flex;
        flex-direction: column;
        min-height: 0;
        transition: border-color 0.2s ease;
      }

      .collapsible-trigger {
        width: 100%;
        border: 1px solid rgba(125, 211, 252, 0.35);
        border-radius: 10px;
        background: rgba(15, 23, 42, 0.75);
        color: #bae6fd;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.6rem;
        padding: 0.4rem 0.6rem;
        font-size: 0.78rem;
        font-weight: 700;
        cursor: pointer;
      }

      .collapsible-chevron {
        font-size: 0.75rem;
        color: #67e8f9;
        transition: transform 0.2s ease;
      }

      .collapsible-block[data-collapsed="true"] .collapsible-chevron {
        transform: rotate(-90deg);
      }

      .collapsible-body {
        min-height: 0;
        flex: 1 1 auto;
        overflow: auto;
      }

      .collapsible-block[data-collapsed="false"] .collapsible-body {
        margin-top: 0.45rem;
      }

      .collapsible-block[data-collapsed="true"] .collapsible-body {
        display: none;
      }

      .collapsible-block[data-collapsed="true"] {
        min-height: 0 !important;
        height: auto !important;
        overflow: visible;
        resize: none;
      }

      .flow-card .collapsible-body,
      .console .collapsible-body,
      .console-landscape .collapsible-body {
        scrollbar-gutter: stable both-edges;
      }

      .metric-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 0.45rem;
        overflow: auto;
      }

      .metric {
        border-radius: 10px;
        background: rgba(30, 41, 59, 0.8);
        border: 1px solid rgba(148, 163, 184, 0.15);
        padding: 0.55rem 0.65rem;
        overflow: auto;
      }

      .metric .label {
        font-size: 0.75rem;
        color: #94a3b8;
      }

      .metric .value {
        margin-top: 0.2rem;
        font-size: 0.95rem;
        font-weight: 700;
        color: #e2e8f0;
      }

      .control-row {
        margin-top: 0.7rem;
        display: flex;
        gap: 0.55rem;
        flex-wrap: wrap;
      }

      .channel-grid {
        margin-top: 0.7rem;
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 0.42rem;
        overflow: auto;
      }

      .channel-card {
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 12px;
        background: rgba(15, 23, 42, 0.62);
        padding: 0.55rem;
        overflow: auto;
      }

      .sortable-item {
        cursor: grab;
      }

      .sortable-item.dragging {
        opacity: 0.45;
        cursor: grabbing;
      }

      .sortable-target {
        outline: 1px dashed rgba(103, 232, 249, 0.9);
        outline-offset: 2px;
      }

      .channel-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
      }

      .channel-name {
        font-size: 0.8rem;
        font-weight: 700;
        color: #e2e8f0;
      }

      .channel-state {
        margin-top: 0.25rem;
        font-size: 0.72rem;
        color: #94a3b8;
      }

      .channel-toggle {
        border: 1px solid rgba(125, 211, 252, 0.45);
        background: rgba(15, 23, 42, 0.8);
        color: #bae6fd;
        border-radius: 8px;
        padding: 0.3rem 0.5rem;
        font-size: 0.72rem;
        cursor: pointer;
      }

      .ctrl-btn {
        border: 1px solid rgba(125, 211, 252, 0.45);
        background: rgba(15, 23, 42, 0.8);
        color: #bae6fd;
        border-radius: 8px;
        padding: 0.45rem 0.72rem;
        font-size: 0.78rem;
        cursor: pointer;
      }

      .ctrl-btn.stop {
        border-color: rgba(251, 113, 133, 0.55);
        color: #fecdd3;
      }

      .console-log {
        margin: 0;
        flex: 1 1 auto;
        min-height: 0;
        overflow-x: hidden;
        overflow-y: auto;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        font-size: 0.76rem;
        line-height: 1.45;
        color: #bfdbfe;
        white-space: pre-wrap;
        word-break: break-word;
      }

      .console h2 {
        margin: 0 0 0.5rem;
        font-size: 0.95rem;
      }

      #consolePane,
      .console-landscape.collapsible-block {
        flex: 1 1 auto;
        min-height: 0;
      }

      .flow-card {
        margin-top: 0.7rem;
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 14px;
        background: rgba(15, 23, 42, 0.56);
        padding: 0.65rem;
      }

      .flow-card h3 {
        margin: 0 0 0.45rem;
        font-size: 0.82rem;
        color: #bfdbfe;
        letter-spacing: 0.02em;
      }


      .task-toolbar {
        margin-bottom: 0.55rem;
        display: flex;
        gap: 0.45rem;
        flex-wrap: wrap;
        align-items: center;
      }

      .task-toolbar select {
        border: 1px solid rgba(125, 211, 252, 0.45);
        background: rgba(15, 23, 42, 0.82);
        color: #bae6fd;
        border-radius: 8px;
        padding: 0.3rem 0.45rem;
        font-size: 0.72rem;
      }

      .task-list {
        display: grid;
        gap: 0.42rem;
        max-height: 220px;
        overflow: auto;
      }

      .task-item {
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 10px;
        background: rgba(15, 23, 42, 0.62);
        padding: 0.45rem;
        display: grid;
        gap: 0.35rem;
      }

      .task-item-head {
        display: flex;
        justify-content: space-between;
        gap: 0.45rem;
        align-items: center;
      }

      .task-name { font-size: 0.78rem; font-weight: 700; color: #e2e8f0; }
      .task-meta { font-size: 0.7rem; color: #94a3b8; }
      .task-actions { display:flex; gap:0.35rem; flex-wrap:wrap; }
      .task-btn {
        border: 1px solid rgba(125, 211, 252, 0.45);
        background: rgba(15, 23, 42, 0.8);
        color: #bae6fd;
        border-radius: 8px;
        padding: 0.24rem 0.45rem;
        font-size: 0.68rem;
        cursor: pointer;
      }
      .task-btn.delete { border-color: rgba(251, 113, 133, 0.55); color: #fecdd3; }
      .task-empty { font-size: 0.74rem; color: #94a3b8; }

      .flow-help {
        margin: 0 0 0.55rem;
        font-size: 0.73rem;
        color: #94a3b8;
      }

      .flow-hint {
        margin-left: 0.4rem;
        color: #67e8f9;
      }

      .flow-svg {
        width: 100%;
        height: 260px;
        display: block;
        border-radius: 10px;
        background: rgba(15, 23, 42, 0.85);
      }

      .flow-legend {
        margin-top: 0.55rem;
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        font-size: 0.7rem;
        color: #cbd5e1;
      }

      .chip {
        border-radius: 999px;
        padding: 0.14rem 0.45rem;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(30, 41, 59, 0.6);
      }

      @media (orientation: landscape) {
        .panel {
          grid-template-columns: minmax(320px, var(--panel-c1)) 14px minmax(320px, var(--panel-c2));
          grid-template-rows: 1fr;
          gap: 0.6rem;
        }

        .stage-shell {
          grid-row: 1;
          grid-column: 1;
          min-width: 0;
        }
        .panel-resizer-top {
          grid-row: 1;
          grid-column: 2;
          display: block;
          min-width: 14px;
          width: 14px;
          align-self: stretch;
          cursor: col-resize;
          z-index: 6;
          touch-action: none;
          border-color: rgba(125, 211, 252, 0.95);
          background: linear-gradient(180deg, rgba(56, 189, 248, 0.68), rgba(14, 116, 144, 0.55));
          box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.45), 0 0 14px rgba(34, 211, 238, 0.28);
        }
        .panel-resizer-top::after {
          width: 6px;
          height: 160px;
          background: rgba(186, 230, 253, 0.98);
        }
        .panel-resizer-bottom { display: none; }
        .dashboard {
          grid-row: 1;
          grid-column: 3;
          min-width: 0;
        }

        .dashboard {
          display: grid;
          grid-template-rows: minmax(180px, var(--dash-r1)) 10px minmax(140px, var(--dash-r2));
          gap: 0.6rem;
        }

        .dashboard-resizer {
          grid-row: 2;
          cursor: row-resize;
        }

        .dashboard-main,
        .console-landscape {
          border: 1px solid rgba(148, 163, 184, 0.2);
          border-radius: 14px;
          background: rgba(15, 23, 42, 0.45);
          padding: 0.75rem;
          overflow: hidden;
        }

        .console { display: none; }
        .console-landscape { display: block; }
      }

      @media (orientation: portrait) {
        .dashboard-main {
          display: block;
        }

        .dashboard-actions {
          margin-top: 0.6rem;
        }

        .status {
          margin-top: 0.35rem;
        }

        .console-landscape { display: none; }
        .dashboard-resizer { display: none; }
      }
    </style>
  </head>
  <body>
    <main class="panel">
      <section class="stage-shell" aria-label="å·¦å´å·¥ä½œå€">
        <section class="stage" aria-label="Pixel Agent å‹•ç•«å€" data-collapsible data-collapsible-label="åŠ©æ‰‹å‹•ç•«å€">
          <div class="stage-controls">
            <span class="upload-label">Pixel Agent å‹•ç•«ï¼ˆGitHub sprite é¢¨æ ¼ï¼‰</span>
            <button id="motionToggle" class="motion-btn" type="button">æš«åœå‹•ä½œ</button>
            <button id="pauseAndClearStage" class="motion-btn" type="button">æš«åœä¸¦æ¸…ç•«é¢</button>
            <button id="spriteGenderToggle" class="motion-btn" type="button">åˆ‡æ›ç‚ºç”·ç”Ÿ</button>
          </div>
          <canvas id="motionCanvas" width="960" height="640" role="img" aria-label="Pixel Agent åƒç´ è§’è‰²å‹•ç•«"></canvas>
        </section>

        <div id="stageResizer" class="resizer stage-shell-resizer" role="separator" aria-orientation="horizontal" tabindex="0" aria-label="èª¿æ•´åŠ©æ‰‹å‹•ç•«å€èˆ‡ Agent å°è©±è¼¸å…¥æ¡†é«˜åº¦"></div>

        <section class="stage-chat" aria-label="æŒ‡ä»¤å°è©±æ¡†" data-collapsible data-collapsible-label="Agent å°è©±è¼¸å…¥æ¡†">
          <h2 style="margin:0;font-size:0.92rem;">Agent å°è©±è¼¸å…¥æ¡†</h2>
          <pre id="chatLog" class="chat-log">[chat] å¯åœ¨æ­¤è¼¸å…¥æŒ‡ä»¤ï¼Œé€è‡³ Gateway -> AnythingLLM</pre>
          <form id="chatForm" class="chat-form">
            <input id="chatInput" class="chat-input" type="text" placeholder="ä¾‹å¦‚ï¼šè«‹æ•´ç†ä»Šå¤©å‘Šè­¦ä¸¦æå‡ºè™•ç½®æ­¥é©Ÿ" required />
            <button id="chatSend" class="chat-send" type="submit">é€å‡º</button>
          </form>
        </section>
      </section>

      <div id="resizerTop" class="resizer panel-resizer-top" role="separator" aria-orientation="horizontal" tabindex="0" aria-label="èª¿æ•´ä¸Šæ–¹èˆ‡ä¸­é–“å€å¡Šé«˜åº¦"></div>

      <section class="dashboard">
        <div class="dashboard-main">
          <div class="dashboard-intro">
            <h1>Agent å•Ÿå‹•é¢æ¿</h1>
            <p>æ­¡è¿ä½¿ç”¨ Agent æ§åˆ¶å°ã€‚æŒ‰ä¸‹æŒ‰éˆ•å¾Œï¼Œç³»çµ±æœƒåˆå§‹åŒ–æµç¨‹ä¸¦é–‹å§‹åŸ·è¡Œä»»å‹™ã€‚</p>
          </div>
          <div class="dashboard-actions">
            <button id="startAgent" class="start-btn" type="button">Start Agent</button>
            <p id="status" class="status" aria-live="polite"></p>
          </div>

          <section class="monitor" aria-label="Agent dashboard">
            <section id="dashboardPane" class="pane" role="region" aria-label="dashboard" data-collapsible data-collapsible-label="ç³»çµ±æŒ‡æ¨™èˆ‡æ§åˆ¶">
            <div class="metric-grid">
              <article class="metric">
                <div class="label">åŠ©æ‰‹ç‹€æ…‹</div>
                <div id="assistantStatus" class="value">Idle</div>
              </article>
              <article class="metric">
                <div class="label">åŸ·è¡Œç‹€æ…‹</div>
                <div id="executionStatus" class="value">æœªåŸ·è¡Œ</div>
              </article>
              <article class="metric">
                <div class="label">é€²åº¦</div>
                <div id="taskProgress" class="value">0%</div>
              </article>
              <article class="metric">
                <div class="label">ç›®å‰ä»»å‹™åŸ·è¡Œæ™‚é–“</div>
                <div id="taskElapsed" class="value">00:00:00</div>
              </article>
              <article class="metric">
                <div class="label">æœ€å¾Œæ›´æ–°</div>
                <div id="lastUpdated" class="value">--:--:--</div>
              </article>
            </div>
            <div class="control-row">
              <button id="pauseAgent" class="ctrl-btn" type="button">æš«åœä»»å‹™</button>
              <button id="resumeAgent" class="ctrl-btn" type="button">æ¢å¾©ä»»å‹™</button>
              <button id="stopAgent" class="ctrl-btn stop" type="button">åœæ­¢ Agent</button>
              <button id="clearConsole" class="ctrl-btn" type="button">æ¸…é™¤ Console</button>
            </div>
            </section>

            <article class="flow-card" aria-label="é€£å…¥æ¥å£æ§åˆ¶" data-collapsible data-collapsible-label="é€£å…¥æ¥å£å¡ç‰‡èˆ‡é–‹é—œ">
              <h3>é€£å…¥æ¥å£å¡ç‰‡èˆ‡é–‹é—œ</h3>
              <p class="flow-help">å¯ç¨ç«‹å•Ÿç”¨/åœç”¨æ¯å€‹æ¥å£ï¼›åœç”¨å¾Œè©²æ¥å£ ingress æœƒå›å‚³ 503ã€‚</p>
              <div class="channel-grid">
                <section class="channel-card" data-channel-card="telegram" data-collapsible data-collapsible-label="é€šé“ï¼šTelegram">
                  <div class="channel-head">
                    <span class="channel-name">Telegram</span>
                    <button class="channel-toggle" data-channel-toggle="telegram" type="button">åˆ‡æ›</button>
                  </div>
                  <div id="channelStateTelegram" class="channel-state">æœªé€£æ¥ï¼ˆå¾…é‡è©¦ï¼‰</div>
                </section>
                <section class="channel-card" data-channel-card="line" data-collapsible data-collapsible-label="é€šé“ï¼šLINE">
                  <div class="channel-head">
                    <span class="channel-name">LINE</span>
                    <button class="channel-toggle" data-channel-toggle="line" type="button">åˆ‡æ›</button>
                  </div>
                  <div id="channelStateLine" class="channel-state">æœªé€£æ¥ï¼ˆå¾…é‡è©¦ï¼‰</div>
                </section>
                <section class="channel-card" data-channel-card="web_ui" data-collapsible data-collapsible-label="é€šé“ï¼šWeb UI">
                  <div class="channel-head">
                    <span class="channel-name">Web UI</span>
                    <button class="channel-toggle" data-channel-toggle="web_ui" type="button">åˆ‡æ›</button>
                  </div>
                  <div id="channelStateWebUi" class="channel-state">æœªé€£æ¥ï¼ˆå¾…é‡è©¦ï¼‰</div>
                </section>
              </div>
            </article>



            <article class="flow-card" aria-label="ä»»å‹™åˆ—è¡¨" data-collapsible data-collapsible-label="ä»»å‹™åˆ—è¡¨ï¼ˆæ’åº/åˆªé™¤ï¼‰">
              <h3>ä»»å‹™åˆ—è¡¨ï¼ˆå¯æ’åº / åˆªé™¤ï¼‰</h3>
              <p class="flow-help">å¯ä¾å»ºç«‹æ™‚é–“ã€æ›´æ–°æ™‚é–“ã€å„ªå…ˆç´šæ’åºï¼›åƒ…å…è¨±åˆªé™¤çµ‚æ…‹ä»»å‹™ï¼ˆsucceeded / failed / cancelledï¼‰ã€‚</p>
              <div class="task-toolbar">
                <label for="taskSort">æ’åºï¼š</label>
                <select id="taskSort">
                  <option value="created_desc">å»ºç«‹æ™‚é–“ï¼ˆæ–°â†’èˆŠï¼‰</option>
                  <option value="created_asc">å»ºç«‹æ™‚é–“ï¼ˆèˆŠâ†’æ–°ï¼‰</option>
                  <option value="updated_desc">æ›´æ–°æ™‚é–“ï¼ˆæ–°â†’èˆŠï¼‰</option>
                  <option value="priority_desc">å„ªå…ˆç´šï¼ˆé«˜â†’ä½ï¼‰</option>
                </select>
                <button id="refreshTasks" class="ctrl-btn" type="button">é‡æ–°æ•´ç†ä»»å‹™</button>
              </div>
              <div id="taskList" class="task-list">
                <div class="task-empty">å°šæœªè¼‰å…¥ä»»å‹™ã€‚</div>
              </div>
            </article>

            <article class="flow-card" aria-label="API è³‡æ–™æµ" data-collapsible data-collapsible-label="API è³‡æ–™æµæ‹“æ¨¸">
              <h3>API è³‡æ–™æµæ‹“æ¨¸ï¼ˆå¡ç‰‡å¼ï¼‰</h3>
              <p class="flow-help">ä»¥æ–¹å¡Šå¡ç‰‡å‘ˆç¾ç›®å‰å…ƒä»¶ï¼ˆUI / Gateway / AnythingLLM / Ollama / gpt-oss:20bï¼‰ï¼Œé€£ç·šæ—æ¨™ç¤ºé€šè¨Šæ–¹å¼ï¼ˆAPI / Local Runtimeï¼‰ã€‚<span class="flow-hint">å¯ç›´æ¥æ‹–æ›³å¡ç‰‡èª¿æ•´æ‹“æ¨¸ã€‚</span></p>
              <svg id="flowSvg" class="flow-svg" viewBox="0 0 980 300" role="img" aria-label="UI åˆ° LLM çš„å¯¦éš›è³‡æ–™æµèˆ‡é€šè¨Šæ–¹å¼"></svg>
              <div class="flow-legend">
                <span class="chip">ğŸŸ¢ Active path</span>
                <span class="chip">ğŸŸ¡ Paused path</span>
                <span class="chip">ğŸ”¹ HTTP API / Webhook</span>
                <span class="chip">ğŸ§  Local runtime / provider call</span>
              </div>
            </article>
          </section>
        </div>

        <div id="dashboardResizer" class="resizer dashboard-resizer" role="separator" aria-orientation="horizontal" tabindex="0" aria-label="èª¿æ•´å³å´é¢æ¿èˆ‡ Console é«˜åº¦"></div>

        <section class="console-landscape" aria-label="console" data-collapsible data-collapsible-label="Consoleï¼ˆæ©«å‘ç‰ˆï¼‰" data-collapsible-collapsed>
          <h2>Console</h2>
          <pre id="consoleLogLandscape" class="console-log">[system] ç­‰å¾…å•Ÿå‹•æŒ‡ä»¤...</pre>
        </section>
      </section>

      <div id="resizerBottom" class="resizer panel-resizer-bottom" role="separator" aria-orientation="horizontal" tabindex="0" aria-label="èª¿æ•´ä¸­é–“èˆ‡ä¸‹æ–¹å€å¡Šé«˜åº¦"></div>

      <section class="console" aria-label="console">
        <h2>Console</h2>
        <section id="consolePane" class="pane" role="region" aria-label="console" data-collapsible data-collapsible-label="Console å…§å®¹" data-collapsible-collapsed>
            <pre id="consoleLog" class="console-log">[system] ç­‰å¾…å•Ÿå‹•æŒ‡ä»¤...</pre>
        </section>
      </section>
    </main>

    <script>
      const button = document.getElementById('startAgent');
      const status = document.getElementById('status');
      const assistantStatus = document.getElementById('assistantStatus');
      const executionStatus = document.getElementById('executionStatus');
      const taskProgress = document.getElementById('taskProgress');
      const taskElapsed = document.getElementById('taskElapsed');
      const lastUpdated = document.getElementById('lastUpdated');
      const consoleLog = document.getElementById('consoleLog');
      const consoleLogLandscape = document.getElementById('consoleLogLandscape');
      const pauseBtn = document.getElementById('pauseAgent');
      const resumeBtn = document.getElementById('resumeAgent');
      const stopBtn = document.getElementById('stopAgent');
      const clearConsoleBtn = document.getElementById('clearConsole');
      const channelStateTelegram = document.getElementById('channelStateTelegram');
      const channelStateLine = document.getElementById('channelStateLine');
      const channelStateWebUi = document.getElementById('channelStateWebUi');
      const channelToggleButtons = document.querySelectorAll('[data-channel-toggle]');
      const taskList = document.getElementById('taskList');
      const taskSort = document.getElementById('taskSort');
      const refreshTasksBtn = document.getElementById('refreshTasks');
      const flowSvg = document.getElementById('flowSvg');
      const motionToggle = document.getElementById('motionToggle');
      const pauseAndClearStageBtn = document.getElementById('pauseAndClearStage');
      const spriteGenderToggle = document.getElementById('spriteGenderToggle');
      const chatForm = document.getElementById('chatForm');
      const chatInput = document.getElementById('chatInput');
      const chatLog = document.getElementById('chatLog');
      const motionCanvas = document.getElementById('motionCanvas');
      const motionCtx = motionCanvas.getContext('2d');
      const panelEl = document.querySelector('.panel');
      const dashboardEl = document.querySelector('.dashboard');
      const stageShellEl = document.querySelector('.stage-shell');
      const resizerTop = document.getElementById('resizerTop');
      const resizerBottom = document.getElementById('resizerBottom');
      const dashboardResizer = document.getElementById('dashboardResizer');
      const stageResizer = document.getElementById('stageResizer');


      const initializeResizableBlocks = () => {
        document.querySelectorAll('.stage, .stage-chat, .pane, .flow-card, .channel-card, .metric, .console, .console-landscape')
          .forEach((block) => {
            if (!(block instanceof HTMLElement)) return;
            block.classList.add('resizable-block');
            if (block.classList.contains('channel-card') || block.classList.contains('metric')) {
              block.classList.add('compact');
            }
          });
      };

      const initializeCollapsibleBlocks = () => {
        const blocks = document.querySelectorAll('[data-collapsible]');
        blocks.forEach((block, index) => {
          block.classList.add('collapsible-block');
          const title = block.dataset.collapsibleLabel || block.getAttribute('aria-label') || `å€å¡Š ${index + 1}`;
          const defaultCollapsed = block.hasAttribute('data-collapsible-collapsed');

          const body = document.createElement('div');
          body.className = 'collapsible-body';
          while (block.firstChild) {
            body.appendChild(block.firstChild);
          }

          const trigger = document.createElement('button');
          trigger.type = 'button';
          trigger.className = 'collapsible-trigger';
          trigger.innerHTML = `<span>${title}</span><span class="collapsible-chevron">â–¾</span>`;

          const setCollapsed = (collapsed) => {
            block.dataset.collapsed = collapsed ? 'true' : 'false';
            trigger.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
            trigger.setAttribute('aria-label', `${collapsed ? 'å±•é–‹' : 'æ”¶åˆ'}${title}`);
          };

          trigger.addEventListener('click', () => {
            const collapsed = block.dataset.collapsed === 'true';
            setCollapsed(!collapsed);
          });

          block.appendChild(trigger);
          block.appendChild(body);
          setCollapsed(defaultCollapsed);
        });
      };

      const initializeSortableGrid = (containerSelector, itemSelector) => {
        const container = document.querySelector(containerSelector);
        if (!(container instanceof HTMLElement)) return;

        let draggingItem = null;

        const items = () => Array.from(container.querySelectorAll(itemSelector)).filter((item) => item instanceof HTMLElement);

        items().forEach((item) => {
          item.setAttribute('draggable', 'true');
          item.classList.add('sortable-item');
        });

        container.addEventListener('dragstart', (event) => {
          const item = event.target.closest(itemSelector);
          if (!(item instanceof HTMLElement)) return;
          draggingItem = item;
          item.classList.add('dragging');
          event.dataTransfer.effectAllowed = 'move';
        });

        container.addEventListener('dragover', (event) => {
          if (!draggingItem) return;
          event.preventDefault();
          const target = event.target.closest(itemSelector);
          if (!(target instanceof HTMLElement) || target === draggingItem) return;
          target.classList.add('sortable-target');

          const rect = target.getBoundingClientRect();
          const insertBefore = event.clientY < rect.top + (rect.height / 2);
          container.insertBefore(draggingItem, insertBefore ? target : target.nextSibling);
        });

        container.addEventListener('dragleave', (event) => {
          const target = event.target.closest(itemSelector);
          if (!(target instanceof HTMLElement)) return;
          target.classList.remove('sortable-target');
        });

        container.addEventListener('drop', (event) => {
          if (!draggingItem) return;
          event.preventDefault();
          container.querySelectorAll('.sortable-target').forEach((node) => node.classList.remove('sortable-target'));
        });

        container.addEventListener('dragend', () => {
          if (draggingItem) draggingItem.classList.remove('dragging');
          container.querySelectorAll('.sortable-target').forEach((node) => node.classList.remove('sortable-target'));
          draggingItem = null;
        });
      };

      let runningMotion = true;

      initializeResizableBlocks();
      initializeCollapsibleBlocks();
      initializeSortableGrid('.metric-grid', '.metric');
      initializeSortableGrid('.channel-grid', '.channel-card');

      const flowConfig = {
        viewBox: { width: 980, height: 300 },
        nodes: [
          { id: 'ui', title: 'Dashboard UI', subtitle: 'approval_ui/index.html', x: 30, y: 105, w: 180, h: 78, kind: 'control' },
          { id: 'gateway', title: 'Gateway', subtitle: '/api/agent/control', x: 250, y: 105, w: 180, h: 78, kind: 'core' },
          { id: 'anythingllm', title: 'AnythingLLM', subtitle: 'Developer API /chat', x: 470, y: 105, w: 180, h: 78, kind: 'brain' },
          { id: 'ollama', title: 'Ollama', subtitle: 'Model Provider', x: 700, y: 40, w: 180, h: 78, kind: 'integration' },
          { id: 'gptoss', title: 'gpt-oss:20b (LLM)', subtitle: 'Inference Runtime', x: 700, y: 180, w: 180, h: 78, kind: 'integration' },
        ],
        edges: [
          { from: 'ui', to: 'gateway', label: 'HTTP API: GET/POST /api/agent/control' },
          { from: 'gateway', to: 'anythingllm', label: 'HTTP API: /api/v1/workspace/:id/chat' },
          { from: 'anythingllm', to: 'ollama', label: 'Provider API call' },
          { from: 'ollama', to: 'gptoss', label: 'Local model runtime' },
        ],
      };

      const flowNodes = flowConfig.nodes.map((node) => ({ ...node }));
      let flowLastControlState = null;
      let flowDragState = null;
      let controlApiConnected = false;
      let channelsApiConnected = false;
      let cachedTasks = [];
      let animationModeOverrideUntil = 0;
      let animationMode = 'sleep';
      let spriteGender = 'female';

      const pixelSize = 8;
      const agentPalette = {
        skin: '#f8d4b6',
        skinShadow: '#e6b892',
        hair: '#3b2f2f',
        hairDark: '#1f1714',
        eye: '#111827',
        mouth: '#e11d48',
        dress: '#ec4899',
        dressShade: '#be185d',
        sleeve: '#f9a8d4',
        legs: '#f2c19a',
        heel: '#111827',
        outline: '#020617',
        glow: '#38bdf8',
      };


      const maleAgentPalette = {
        ...agentPalette,
        hair: '#312e81',
        hairDark: '#1e1b4b',
        mouth: '#b91c1c',
        dress: '#2563eb',
        dressShade: '#1d4ed8',
        sleeve: '#93c5fd',
        legs: '#334155',
        heel: '#0f172a',
      };

      const drawPixelRect = (x, y, w, h, color) => {
        if (!color) return;
        motionCtx.fillStyle = color;
        motionCtx.fillRect(
          Math.round(x) * pixelSize,
          Math.round(y) * pixelSize,
          Math.max(1, Math.round(w)) * pixelSize,
          Math.max(1, Math.round(h)) * pixelSize,
        );
      };

      const drawPixelAgent = (anchorX, anchorY, frame, gender) => {
        const px = (ox, oy, w, h, color) => drawPixelRect(anchorX + ox, anchorY + oy, w, h, color);
        const palette = gender === 'male' ? maleAgentPalette : agentPalette;

        const bodyBob = Math.round(frame.bodyBob);
        const armSwing = Math.round(frame.armSwing);
        const legSwing = Math.round(frame.legSwing);
        const mouthOpen = Math.max(0, Math.round(frame.mouthOpen));

        const y = bodyBob;
        const leftLegStep = Math.max(0, legSwing);
        const rightLegStep = Math.max(0, -legSwing);

        // é ­é«®
        if (gender === 'male') {
          px(7, 1 + y, 8, 1, palette.hairDark);
          px(6, 2 + y, 10, 2, palette.hair);
          px(7, 4 + y, 8, 1, palette.hairDark);
        } else {
          px(7, 1 + y, 8, 1, palette.hairDark);
          px(6, 2 + y, 10, 2, palette.hair);
          px(6, 4 + y, 2, 8, palette.hairDark);
          px(14, 4 + y, 2, 8, palette.hairDark);
        }

        // è‡‰éƒ¨
        px(8, 3 + y, 6, 5, palette.skin);
        px(8, 8 + y, 6, 1, palette.skinShadow);
        px(8, 3 + y, 1, 6, palette.outline);
        px(13, 3 + y, 1, 6, palette.outline);

        // äº”å®˜
        px(9, 5 + y, 1, 1, palette.eye);
        px(12, 5 + y, 1, 1, palette.eye);
        px(10, 7 + y, 2, 1 + mouthOpen, palette.mouth);

        // è‚©è†€èˆ‡æ´‹è£ä¸Šèº«
        px(8, 9 + y, 6, 1, palette.sleeve);
        px(8, 10 + y, 6, 2, palette.dress);

        // æ‰‹è‡‚
        px(6 - armSwing, 10 + y, 2, 2, palette.sleeve);
        px(5 - armSwing, 12 + y, 2, 3, palette.skin);
        px(14 + armSwing, 10 + y, 2, 2, palette.sleeve);
        px(15 + armSwing, 12 + y, 2, 3, palette.skin);

        // æ´‹è£è£™è¥¬ï¼ˆA-lineï¼‰
        px(7, 12 + y, 8, 2, palette.dress);
        px(6, 14 + y, 10, 2, palette.dress);
        px(5, 16 + y, 12, 2, palette.dressShade);

        // é›™è…¿ï¼ˆä¿®å¾©ï¼šè…¿æ˜ç¢ºç•«åœ¨è£™è¥¬ä¸‹æ–¹ï¼‰
        px(8, 18 + y, 2, 3 + leftLegStep, palette.legs);
        px(12, 18 + y, 2, 3 + rightLegStep, palette.legs);

        // é«˜è·Ÿé‹
        px(8, 21 + y + leftLegStep, 2, 1, palette.heel);
        px(12, 21 + y + rightLegStep, 2, 1, palette.heel);
        px(9, 22 + y + leftLegStep, 2, 1, palette.heel);
        px(13, 22 + y + rightLegStep, 2, 1, palette.heel);

        // è¼ªå»“å¼·åŒ–
        px(5, 16 + y, 1, 7, palette.outline);
        px(16, 16 + y, 1, 7, palette.outline);
      };

      const drawSpeechBubble = (x, y, text, pulse) => {
        motionCtx.save();
        motionCtx.fillStyle = 'rgba(15, 23, 42, 0.88)';
        motionCtx.strokeStyle = 'rgba(103, 232, 249, 0.9)';
        motionCtx.lineWidth = 2;
        motionCtx.beginPath();
        motionCtx.roundRect(x, y, 220, 72, 12);
        motionCtx.fill();
        motionCtx.stroke();

        motionCtx.fillStyle = '#a5f3fc';
        motionCtx.font = '700 18px "Noto Sans TC", sans-serif';
        motionCtx.fillText(text, x + 16, y + 43);

        motionCtx.fillStyle = `rgba(56, 189, 248, ${0.25 + pulse * 0.2})`;
        motionCtx.beginPath();
        motionCtx.arc(x + 210, y + 16, 6 + pulse * 3, 0, Math.PI * 2);
        motionCtx.fill();
        motionCtx.restore();
      };

      const drawThoughtBubble = (x, y, pulse) => {
        motionCtx.save();
        motionCtx.fillStyle = 'rgba(148, 163, 184, 0.18)';
        motionCtx.strokeStyle = 'rgba(191, 219, 254, 0.85)';
        motionCtx.lineWidth = 2;
        motionCtx.beginPath();
        motionCtx.ellipse(x, y, 80 + pulse * 8, 34 + pulse * 4, 0, 0, Math.PI * 2);
        motionCtx.fill();
        motionCtx.stroke();

        motionCtx.beginPath();
        motionCtx.arc(x - 72, y + 34, 9, 0, Math.PI * 2);
        motionCtx.fill();
        motionCtx.stroke();

        motionCtx.beginPath();
        motionCtx.arc(x - 90, y + 50, 6, 0, Math.PI * 2);
        motionCtx.fill();
        motionCtx.stroke();

        motionCtx.fillStyle = '#dbeafe';
        motionCtx.font = '700 16px "Noto Sans TC", sans-serif';
        motionCtx.fillText('åˆ†æä¸­...', x - 42, y + 6);
        motionCtx.restore();
      };

      const resolveAnimationState = (timestamp) => {
        const seconds = timestamp / 1000;
        const phase = seconds % 18;

        const buildState = (mode, t) => {
          if (mode === 'sleep') {
            return {
              mode: 'sleep',
              stageText: 'æœªé€£æ¥ãƒ»ç¡çœ å¾…å‘½',
              horizontalShift: 0,
              bodyBob: Math.sin(t * 0.8) * 0.2,
              armSwing: 0,
              legSwing: 0,
              mouthOpen: 0,
              pulse: (Math.sin(t * 0.4) + 1) / 2,
            };
          }

          if (mode === 'talk') {
            return {
              mode: 'talk',
              stageText: 'å°è©±å›è¦†ä¸­',
              horizontalShift: 0,
              bodyBob: Math.sin(t * 0.35) * 0.6,
              armSwing: 1 + Math.sin(t) * 1.2,
              legSwing: 0,
              mouthOpen: (Math.sin(t) + 1) * 0.9,
              pulse: (Math.sin(t * 0.8) + 1) / 2,
            };
          }

          if (mode === 'think') {
            return {
              mode: 'think',
              stageText: 'åˆ†æèˆ‡è¦åŠƒä¸­',
              horizontalShift: Math.sin(t * 0.45) * 1.5,
              bodyBob: Math.sin(t * 0.6) * 0.5,
              armSwing: -1,
              legSwing: 0,
              mouthOpen: 0,
              pulse: (Math.sin(t) + 1) / 2,
            };
          }

          if (mode === 'paused' || mode === 'stopped') {
            return {
              mode: 'idle',
              stageText: mode === 'paused' ? 'ä»»å‹™æš«åœ' : 'ä»»å‹™åœæ­¢',
              horizontalShift: 0,
              bodyBob: Math.sin(t * 0.7) * 0.15,
              armSwing: 0,
              legSwing: 0,
              mouthOpen: 0,
              pulse: (Math.sin(t * 0.5) + 1) / 2,
            };
          }

          if (mode === 'running') {
            return {
              mode: 'walk',
              stageText: 'åŸ·è¡Œä»»å‹™ä¸­',
              horizontalShift: Math.sin(t * 0.7) * 2.8,
              bodyBob: Math.sin(t * 3.2) * 0.8,
              armSwing: Math.sin(t * 3.2) * 1.8,
              legSwing: Math.sin(t * 3.2 + Math.PI) * 1.6,
              mouthOpen: 0,
              pulse: (Math.sin(t * 3.2) + 1) / 2,
            };
          }

          return {
            mode: 'idle',
            stageText: 'å¾…å‘½ä¸­',
            horizontalShift: Math.sin(phase * 0.35) * 0.6,
            bodyBob: Math.sin(t * 0.9) * 0.25,
            armSwing: Math.sin(t * 0.6) * 0.35,
            legSwing: 0,
            mouthOpen: 0,
            pulse: (Math.sin(t * 0.5) + 1) / 2,
          };
        };

        return buildState(animationMode, seconds);
      };
      motionToggle.addEventListener('click', () => {
        runningMotion = !runningMotion;
        motionToggle.textContent = runningMotion ? 'æš«åœå‹•ä½œ' : 'ç¹¼çºŒå‹•ä½œ';
        if (runningMotion) {
          requestAnimationFrame(renderMotion);
        }
      });

      const clearStageCanvas = () => {
        motionCtx.clearRect(0, 0, motionCanvas.width, motionCanvas.height);
        motionCtx.fillStyle = '#020617';
        motionCtx.fillRect(0, 0, motionCanvas.width, motionCanvas.height);
      };

      pauseAndClearStageBtn.addEventListener('click', () => {
        runningMotion = false;
        motionToggle.textContent = 'ç¹¼çºŒå‹•ä½œ';
        clearStageCanvas();
        appendLog('[stage] å·²æš«åœ Pixel Agent å‹•ç•«ä¸¦æ¸…é™¤å·¦å´ç•«é¢');
      });

      spriteGenderToggle?.addEventListener('click', () => {
        spriteGender = spriteGender === 'female' ? 'male' : 'female';
        spriteGenderToggle.textContent = spriteGender === 'female' ? 'åˆ‡æ›ç‚ºç”·ç”Ÿ' : 'åˆ‡æ›ç‚ºå¥³ç”Ÿ';
      });

      const renderMotion = (timestamp) => {
        motionCtx.clearRect(0, 0, motionCanvas.width, motionCanvas.height);

        const gradient = motionCtx.createLinearGradient(0, 0, motionCanvas.width, motionCanvas.height);
        gradient.addColorStop(0, '#f3f4f6');
        gradient.addColorStop(1, '#d1d5db');
        motionCtx.fillStyle = gradient;
        motionCtx.fillRect(0, 0, motionCanvas.width, motionCanvas.height);

        const state = resolveAnimationState(timestamp);
        const spriteWidthCells = 24;
        const spriteHeightCells = 28;
        const canvasWidthCells = motionCanvas.width / pixelSize;
        const canvasHeightCells = motionCanvas.height / pixelSize;

        const baseCellX = Math.floor(((canvasWidthCells - spriteWidthCells) / 2) + state.horizontalShift);
        const baseCellY = Math.floor(((canvasHeightCells - spriteHeightCells) / 2) + 2);
        const basePixelX = baseCellX * pixelSize;
        const basePixelY = baseCellY * pixelSize;

        drawPixelAgent(baseCellX, baseCellY, state, spriteGender);

        motionCtx.fillStyle = '#94a3b8';
        motionCtx.font = '600 18px "Noto Sans TC", sans-serif';
        motionCtx.fillText(`Pixel Agent ${spriteGender === 'female' ? 'å¥³ç”Ÿ' : 'ç”·ç”Ÿ'}ï¼ˆ${state.stageText}ï¼‰`, 80, 56);

        motionCtx.fillStyle = `rgba(56, 189, 248, ${0.22 + state.pulse * 0.3})`;
        motionCtx.beginPath();
        motionCtx.ellipse(basePixelX + (12 * pixelSize), basePixelY + (28 * pixelSize) + 14, 74 + state.pulse * 16, 18, 0, 0, Math.PI * 2);
        motionCtx.fill();

        if (state.mode === 'talk') {
          drawSpeechBubble(basePixelX + 190, basePixelY + 30, 'æ­£åœ¨å›ç­”ä½ çš„å•é¡Œ', state.pulse);
        } else if (state.mode === 'think') {
          drawThoughtBubble(basePixelX + 216, basePixelY - 8, state.pulse);
        }

        if (runningMotion) {
          requestAnimationFrame(renderMotion);
        }
      };

      requestAnimationFrame(renderMotion);

      const toLocalTime = (iso) => {
        if (!iso) return '--:--:--';
        return new Date(iso).toLocaleTimeString('zh-Hant-TW', { hour12: false });
      };

      const scrollToBottom = (element) => {
        if (!(element instanceof HTMLElement)) return;
        element.scrollTop = element.scrollHeight;
      };

      const scrollConsoleToLatest = () => {
        [consoleLog, consoleLogLandscape].forEach((targetLog) => {
          if (!(targetLog instanceof HTMLElement)) return;
          scrollToBottom(targetLog);
          // çœŸæ­£å¯æ»¾å‹•çš„å®¹å™¨æœ‰æ™‚æ˜¯åŒ…ä½ <pre> çš„çˆ¶å±¤ï¼ˆä¾‹å¦‚æ”¶åˆå®¹å™¨ï¼‰ã€‚
          scrollToBottom(targetLog.parentElement);
          scrollToBottom(targetLog.closest('.collapsible-body'));
        });

        // å€å¡Šè¢«æ”¶åˆå¾Œå†å±•é–‹æ™‚ï¼Œéœ€ç­‰å¾…æ’ç‰ˆå®Œæˆæ‰å¯æ­£ç¢ºæ²å‹•åˆ°åº•ã€‚
        window.requestAnimationFrame(() => {
          [consoleLog, consoleLogLandscape].forEach((targetLog) => {
            if (!(targetLog instanceof HTMLElement)) return;
            scrollToBottom(targetLog);
            scrollToBottom(targetLog.parentElement);
            scrollToBottom(targetLog.closest('.collapsible-body'));
          });
        });
      };

      const appendLog = (text) => {
        [consoleLog, consoleLogLandscape].forEach((targetLog) => {
          targetLog.textContent += `\n${text}`;
        });
        scrollConsoleToLatest();
      };

      const appendChatLog = (speaker, text) => {
        chatLog.textContent += `\n[${speaker}] ${text}`;
        chatLog.scrollTop = chatLog.scrollHeight;
      };

      const pad2 = (value) => String(value).padStart(2, '0');
      const formatDuration = (totalMs) => {
        const totalSeconds = Math.max(0, Math.floor(totalMs / 1000));
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        return `${pad2(hours)}:${pad2(minutes)}:${pad2(seconds)}`;
      };

      let taskElapsedMs = 0;
      let taskRunStartedAtMs = null;
      let taskTimerId = null;
      let currentRunState = 'idle';

      const renderTaskElapsed = () => {
        if (!taskElapsed) return;
        const runningDelta = taskRunStartedAtMs ? (Date.now() - taskRunStartedAtMs) : 0;
        taskElapsed.textContent = formatDuration(taskElapsedMs + runningDelta);
      };

      const ensureTaskTimer = () => {
        if (taskTimerId) return;
        taskTimerId = window.setInterval(renderTaskElapsed, 1000);
      };

      const clearTaskTimer = () => {
        if (!taskTimerId) return;
        window.clearInterval(taskTimerId);
        taskTimerId = null;
      };

      const reconcileTaskElapsed = (nextState) => {
        if (nextState === 'idle' || nextState === 'stopped') {
          taskElapsedMs = 0;
          taskRunStartedAtMs = null;
          clearTaskTimer();
          renderTaskElapsed();
          currentRunState = nextState;
          return;
        }

        if (nextState === 'running') {
          if (currentRunState !== 'running') {
            taskRunStartedAtMs = Date.now();
          }
          ensureTaskTimer();
          renderTaskElapsed();
          currentRunState = nextState;
          return;
        }

        if (nextState === 'paused') {
          if (taskRunStartedAtMs) {
            taskElapsedMs += Date.now() - taskRunStartedAtMs;
            taskRunStartedAtMs = null;
          }
          clearTaskTimer();
          renderTaskElapsed();
          currentRunState = nextState;
        }
      };

      const clientToFlowPoint = (clientX, clientY) => {
        const rect = flowSvg.getBoundingClientRect();
        const scaleX = flowConfig.viewBox.width / rect.width;
        const scaleY = flowConfig.viewBox.height / rect.height;
        return {
          x: (clientX - rect.left) * scaleX,
          y: (clientY - rect.top) * scaleY,
        };
      };

      const startFlowDrag = (event) => {
        if (event.button !== 0 || !flowSvg) return;
        const nodeGroup = event.target.closest('[data-node-id]');
        if (!nodeGroup) return;

        const nodeId = nodeGroup.dataset.nodeId;
        const node = flowNodes.find((item) => item.id === nodeId);
        if (!node) return;

        const pointer = clientToFlowPoint(event.clientX, event.clientY);
        flowDragState = {
          node,
          pointerId: event.pointerId,
          offsetX: pointer.x - node.x,
          offsetY: pointer.y - node.y,
        };

        flowSvg.setPointerCapture(event.pointerId);
      };

      const moveFlowDrag = (event) => {
        if (!flowDragState || flowDragState.pointerId !== event.pointerId) return;

        const pointer = clientToFlowPoint(event.clientX, event.clientY);
        const { node, offsetX, offsetY } = flowDragState;
        node.x = clamp(pointer.x - offsetX, 10, flowConfig.viewBox.width - node.w - 10);
        node.y = clamp(pointer.y - offsetY, 10, flowConfig.viewBox.height - node.h - 10);

        renderFlow(flowLastControlState);
      };

      const endFlowDrag = (event) => {
        if (!flowDragState || flowDragState.pointerId !== event.pointerId) return;
        flowSvg.releasePointerCapture(event.pointerId);
        flowDragState = null;
      };

      flowSvg?.addEventListener('pointerdown', startFlowDrag);
      flowSvg?.addEventListener('pointermove', moveFlowDrag);
      flowSvg?.addEventListener('pointerup', endFlowDrag);
      flowSvg?.addEventListener('pointercancel', endFlowDrag);

      const renderFlow = (controlState) => {
        if (!flowSvg) return;
        flowLastControlState = controlState;

        const nodeMap = new Map(flowNodes.map((node) => [node.id, node]));
        const isActive = controlState?.state === 'running';
        const isPaused = controlState?.state === 'paused';

        const edgeColor = isActive ? '#22d3ee' : (isPaused ? '#f59e0b' : '#64748b');

        const edgeMarkup = flowConfig.edges.map((edge) => {
          const from = nodeMap.get(edge.from);
          const to = nodeMap.get(edge.to);
          if (!from || !to) return '';

          const startX = from.x + from.w;
          const startY = from.y + (from.h / 2);
          const endX = to.x;
          const endY = to.y + (to.h / 2);
          const bendX = (startX + endX) / 2;
          const path = `M ${startX} ${startY} C ${bendX} ${startY}, ${bendX} ${endY}, ${endX} ${endY}`;

          const labelX = bendX;
          const labelY = ((startY + endY) / 2) - 8;

          return `
            <path d="${path}" fill="none" stroke="${edgeColor}" stroke-width="3" marker-end="url(#arrowhead)" opacity="0.9" />
            <rect x="${labelX - 130}" y="${labelY - 11}" width="260" height="18" rx="9" fill="rgba(15,23,42,0.95)" stroke="rgba(148,163,184,0.35)" />
            <text x="${labelX}" y="${labelY + 2}" fill="#cbd5e1" font-size="11" text-anchor="middle">${edge.label}</text>
          `;
        }).join('');

        const nodeMarkup = flowNodes.map((node) => {
          const fillByKind = {
            integration: '#0f172a',
            core: '#0b253a',
            control: '#1e1b4b',
            brain: '#032d39',
          };

          const activeNode = isActive && ['gateway', 'anythingllm', 'ollama', 'gptoss'].includes(node.id);
          const pausedNode = isPaused && ['gateway', 'anythingllm'].includes(node.id);
          const stroke = activeNode ? '#22d3ee' : (pausedNode ? '#f59e0b' : '#64748b');
          const titleX = node.x + 12;
          const titleY = node.y + 28;

          return `
            <g data-node-id="${node.id}" style="cursor: grab;">
              <rect x="${node.x}" y="${node.y}" width="${node.w}" height="${node.h}" rx="12" fill="${fillByKind[node.kind] || '#0f172a'}" stroke="${stroke}" stroke-width="2.5" />
              <text x="${titleX}" y="${titleY}" fill="#e2e8f0" font-size="14" font-weight="700">${node.title}</text>
              <text x="${titleX}" y="${titleY + 20}" fill="#94a3b8" font-size="11">${node.subtitle}</text>
            </g>
          `;
        }).join('');

        flowSvg.innerHTML = `
          <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="8" refY="3.5" orient="auto">
              <polygon points="0 0, 10 3.5, 0 7" fill="#94a3b8"></polygon>
            </marker>
          </defs>
          <g>
            ${edgeMarkup}
            ${nodeMarkup}
          </g>
        `;
      };

      const setAnimationMode = (nextMode, durationMs = 0) => {
        animationMode = nextMode;
        animationModeOverrideUntil = durationMs > 0 ? Date.now() + durationMs : 0;
      };

      const syncAnimationWithControlState = (controlState) => {
        if (Date.now() < animationModeOverrideUntil) return;
        if (!controlApiConnected) {
          setAnimationMode('sleep');
          return;
        }

        const runState = controlState?.state;

        if (runState === 'paused') {
          setAnimationMode('paused');
          return;
        }

        if (runState === 'running') {
          setAnimationMode('running');
          return;
        }

        if (runState === 'stopped') {
          setAnimationMode('stopped');
          return;
        }

        setAnimationMode('idle');
      };

      const setControlButtons = ({ start, pause, resume, stop }) => {
        button.disabled = !start;
        pauseBtn.disabled = !pause;
        resumeBtn.disabled = !resume;
        stopBtn.disabled = !stop;
      };

      const applyControlState = (data) => {
        reconcileTaskElapsed(data.state);
        assistantStatus.textContent = data.assistant_status;
        executionStatus.textContent = data.execution_status;
        taskProgress.textContent = `${data.task_progress}%`;
        lastUpdated.textContent = toLocalTime(data.last_updated_at);

        setControlButtons({
          start: Boolean(data.can?.start),
          pause: Boolean(data.can?.pause),
          resume: Boolean(data.can?.resume),
          stop: Boolean(data.can?.stop),
        });
        syncAnimationWithControlState(data);
        renderFlow(data);
      };

      const renderChannels = (channels) => {
        const mapping = {
          telegram: channelStateTelegram,
          line: channelStateLine,
          web_ui: channelStateWebUi,
        };

        Object.entries(mapping).forEach(([key, target]) => {
          const item = channels[key];
          if (!item) return;
          const enabledText = item.enabled ? 'ç›®å‰ï¼šå•Ÿç”¨' : 'ç›®å‰ï¼šåœç”¨';
          const connectionText = item.connected ? 'å·²é€£æ¥ï¼ˆæœ‰å¯¦éš›æµé‡ï¼‰' : 'æœªé€£æ¥ï¼ˆå°šç„¡æµé‡ï¼‰';
          const lastActivityText = item.last_activity_at ? `æœ€å¾Œæ´»å‹•ï¼š${toLocalTime(item.last_activity_at)}` : 'æœ€å¾Œæ´»å‹•ï¼š--';
          target.textContent = `${enabledText}ï½œç‹€æ…‹ï¼š${connectionText}ï½œ${lastActivityText}`;
          target.style.color = item.enabled ? (item.connected ? '#67e8f9' : '#fde68a') : '#fda4af';
          const button = document.querySelector(`[data-channel-toggle="${key}"]`);
          if (button) {
            button.dataset.enabled = item.enabled ? 'true' : 'false';
            button.textContent = item.enabled ? 'é—œé–‰' : 'é–‹å•Ÿ';
            button.disabled = false;
          }
        });
      };

      const renderChannelsDisconnected = (message = 'Gateway é€šé“ API æœªé€£æ¥') => {
        const mapping = {
          telegram: channelStateTelegram,
          line: channelStateLine,
          web_ui: channelStateWebUi,
        };

        Object.values(mapping).forEach((target) => {
          target.textContent = `æœªé€£æ¥ï¼ˆ${message}ï¼‰`;
          target.style.color = '#fda4af';
        });

        channelToggleButtons.forEach((buttonEl) => {
          buttonEl.textContent = 'é‡è©¦';
          buttonEl.disabled = false;
          delete buttonEl.dataset.enabled;
        });
      };

      const taskStatusPriority = {
        running: 6,
        pending: 5,
        retry_scheduled: 4,
        failed: 3,
        cancelled: 2,
        succeeded: 1,
      };

      const sortTasks = (tasks, sortKey) => {
        const list = [...tasks];
        if (sortKey === 'created_asc') return list.sort((a, b) => a.created_at.localeCompare(b.created_at));
        if (sortKey === 'updated_desc') return list.sort((a, b) => b.updated_at.localeCompare(a.updated_at));
        if (sortKey === 'priority_desc') return list.sort((a, b) => (b.priority - a.priority) || ((taskStatusPriority[b.status] || 0) - (taskStatusPriority[a.status] || 0)));
        return list.sort((a, b) => b.created_at.localeCompare(a.created_at));
      };

      const renderTaskList = (tasks) => {
        if (!taskList) return;
        if (!tasks.length) {
          taskList.innerHTML = '<div class="task-empty">ç›®å‰æ²’æœ‰ä»»å‹™ã€‚</div>';
          return;
        }

        taskList.innerHTML = tasks.map((task) => {
          const canDelete = ['succeeded', 'failed', 'cancelled'].includes(task.status);
          return `
            <article class="task-item">
              <div class="task-item-head">
                <span class="task-name">${task.name}</span>
                <span class="task-meta">${task.status}</span>
              </div>
              <div class="task-meta">id: ${task.id}</div>
              <div class="task-meta">priority: ${task.priority}ï½œå»ºç«‹ï¼š${toLocalTime(task.created_at)}ï½œæ›´æ–°ï¼š${toLocalTime(task.updated_at)}</div>
              <div class="task-actions">
                <button class="task-btn delete" data-task-delete="${task.id}" type="button" ${canDelete ? '' : 'disabled'}>åˆªé™¤</button>
              </div>
            </article>
          `;
        }).join('');
      };

      const refreshTasks = async () => {
        const response = await fetch('/api/tasks');
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'è®€å–ä»»å‹™åˆ—è¡¨å¤±æ•—');
        }
        cachedTasks = Array.isArray(payload.data) ? payload.data : [];
        renderTaskList(sortTasks(cachedTasks, taskSort?.value || 'created_desc'));
      };

      const deleteTaskById = async (taskId) => {
        const response = await fetch(`/api/tasks/${taskId}`, { method: 'DELETE' });
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'åˆªé™¤ä»»å‹™å¤±æ•—');
        }
      };

      const refreshChannels = async () => {
        const response = await fetch('/api/channels');
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'è®€å–æ¥å£ç‹€æ…‹å¤±æ•—');
        }
        channelsApiConnected = true;
        renderChannels(payload.data);
      };

      const toggleChannel = async (channel, enabled) => {
        const response = await fetch('/api/channels', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ channel, enabled }),
        });
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'åˆ‡æ›æ¥å£å¤±æ•—');
        }
        channelsApiConnected = true;
        renderChannels(payload.data);
      };

      const refreshState = async () => {
        const response = await fetch('/api/agent/control');
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'è®€å– Agent ç‹€æ…‹å¤±æ•—');
        }
        controlApiConnected = true;
        applyControlState(payload.data);
      };

      const sendControl = async (action) => {
        const response = await fetch('/api/agent/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action }),
        });
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || `${action} å¤±æ•—`);
        }
        applyControlState(payload.data);
        return payload.data;
      };

      const sendCommand = async (text) => {
        setAnimationMode('think', 2200);
        const response = await fetch('/api/agent/command', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text }),
        });
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'ç™¼é€æŒ‡ä»¤å¤±æ•—');
        }
        setAnimationMode('talk', 2800);
        return payload.reply;
      };

      button.addEventListener('click', async () => {
        try {
          status.textContent = 'Agent å•Ÿå‹•ä¸­...';
          await sendControl('start');
          status.textContent = 'Agent å·²å•Ÿå‹•ï¼Œç§˜æ›¸å¾…å‘½ä¸­ã€‚';
          appendLog('[control] ä½¿ç”¨è€…å•Ÿå‹• Agent');
        } catch (error) {
          status.textContent = `å•Ÿå‹•å¤±æ•—ï¼š${error.message}`;
          appendLog(`[error] å•Ÿå‹•å¤±æ•—ï¼š${error.message}`);
        }
      });

      pauseBtn.addEventListener('click', async () => {
        try {
          await sendControl('pause');
          status.textContent = 'Agent å·²æš«åœã€‚';
          appendLog('[control] ä½¿ç”¨è€…æš«åœä»»å‹™');
        } catch (error) {
          status.textContent = `æš«åœå¤±æ•—ï¼š${error.message}`;
          appendLog(`[error] æš«åœå¤±æ•—ï¼š${error.message}`);
        }
      });

      resumeBtn.addEventListener('click', async () => {
        try {
          await sendControl('resume');
          status.textContent = 'Agent å·²æ¢å¾©åŸ·è¡Œã€‚';
          appendLog('[control] ä½¿ç”¨è€…æ¢å¾©ä»»å‹™');
        } catch (error) {
          status.textContent = `æ¢å¾©å¤±æ•—ï¼š${error.message}`;
          appendLog(`[error] æ¢å¾©å¤±æ•—ï¼š${error.message}`);
        }
      });

      stopBtn.addEventListener('click', async () => {
        try {
          await sendControl('stop');
          status.textContent = 'Agent å·²åœæ­¢ã€‚';
          appendLog('[control] ä½¿ç”¨è€…åœæ­¢ Agent');
        } catch (error) {
          status.textContent = `åœæ­¢å¤±æ•—ï¼š${error.message}`;
          appendLog(`[error] åœæ­¢å¤±æ•—ï¼š${error.message}`);
        }
      });


      chatForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        const text = chatInput.value.trim();
        if (!text) return;

        chatInput.disabled = true;
        appendChatLog('user', text);
        appendLog(`[command] UI æŒ‡ä»¤é€å‡ºï¼š${text}`);

        try {
          const reply = await sendCommand(text);
          appendChatLog('agent', reply);
          status.textContent = 'å·²æ”¶åˆ° Agent å›è¦†ã€‚';
          appendLog('[command] æŒ‡ä»¤å®Œæˆ');
        } catch (error) {
          appendChatLog('error', error.message);
          status.textContent = `æŒ‡ä»¤å¤±æ•—ï¼š${error.message}`;
          appendLog(`[error] æŒ‡ä»¤å¤±æ•—ï¼š${error.message}`);
        } finally {
          chatInput.disabled = false;
          chatInput.value = '';
          chatInput.focus();
        }
      });

      channelToggleButtons.forEach((buttonEl) => {
        buttonEl.addEventListener('click', async () => {
          const channel = buttonEl.dataset.channelToggle;
          buttonEl.disabled = true;
          try {
            if (!channelsApiConnected) {
              status.textContent = 'é‡æ–°å˜—è©¦é€£æ¥é€šé“ç‹€æ…‹...';
              await refreshChannels();
              status.textContent = 'é€šé“ç‹€æ…‹ API å·²é€£ç·šã€‚';
              appendLog('[channel] å·²é‡æ–°é€£æ¥é€šé“ç‹€æ…‹ API');
              return;
            }

            const isEnabled = buttonEl.dataset.enabled === 'true';
            const nextEnabled = !isEnabled;
            await toggleChannel(channel, nextEnabled);
            appendLog(`[channel] ${channel} å·²${nextEnabled ? 'é–‹å•Ÿ' : 'é—œé–‰'}`);
          } catch (error) {
            channelsApiConnected = false;
            renderChannelsDisconnected('è«‹æŒ‰é‡è©¦é‡æ–°é€£ç·š');
            status.textContent = `æ¥å£åˆ‡æ›å¤±æ•—ï¼š${error.message}`;
            appendLog(`[error] æ¥å£åˆ‡æ›å¤±æ•—ï¼š${error.message}`);
          } finally {
            buttonEl.disabled = false;
          }
        });
      });

      if (taskSort) {
        taskSort.addEventListener('change', () => {
          renderTaskList(sortTasks(cachedTasks, taskSort.value));
        });
      }

      if (refreshTasksBtn) {
        refreshTasksBtn.addEventListener('click', async () => {
          try {
            await refreshTasks();
            appendLog('[task] ä»»å‹™åˆ—è¡¨å·²æ›´æ–°');
          } catch (error) {
            status.textContent = `ä»»å‹™åˆ—è¡¨æ›´æ–°å¤±æ•—ï¼š${error.message}`;
            appendLog(`[error] ä»»å‹™åˆ—è¡¨æ›´æ–°å¤±æ•—ï¼š${error.message}`);
          }
        });
      }

      if (taskList) {
        taskList.addEventListener('click', async (event) => {
          const target = event.target;
          if (!(target instanceof HTMLElement)) return;
          const taskId = target.dataset.taskDelete;
          if (!taskId) return;
          target.setAttribute('disabled', 'true');
          try {
            await deleteTaskById(taskId);
            appendLog(`[task] å·²åˆªé™¤ä»»å‹™ ${taskId}`);
            await refreshTasks();
          } catch (error) {
            status.textContent = `åˆªé™¤ä»»å‹™å¤±æ•—ï¼š${error.message}`;
            appendLog(`[error] åˆªé™¤ä»»å‹™å¤±æ•—ï¼š${error.message}`);
            target.removeAttribute('disabled');
          }
        });
      }

      clearConsoleBtn.addEventListener('click', () => {
        [consoleLog, consoleLogLandscape].forEach((targetLog) => {
          targetLog.textContent = '[system] console å·²æ¸…ç©º';
        });
        scrollConsoleToLatest();
        lastUpdated.textContent = toLocalTime(new Date().toISOString());
      });

      document.addEventListener('click', (event) => {
        if (!(event.target instanceof HTMLElement) || !event.target.classList.contains('collapsible-trigger')) return;
        const parentBlock = event.target.closest('[aria-label="console"]');
        if (!parentBlock) return;
        window.requestAnimationFrame(scrollConsoleToLatest);
      });


      const clamp = (value, min, max) => Math.max(min, Math.min(value, max));

      const setupResizer = ({ handle, onStart, onMove, onEnd, cursor }) => {
        if (!handle) return;

        handle.addEventListener('mousedown', (event) => {
          event.preventDefault();
          const startState = onStart(event);
          if (!startState) return;
          document.body.style.cursor = cursor;
          document.body.style.userSelect = 'none';

          const onMouseMove = (moveEvent) => onMove(moveEvent, startState);
          const onMouseUp = () => {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            if (onEnd) onEnd();
          };

          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });
      };

      setupResizer({
        handle: resizerTop,
        cursor: 'row-resize',
        onStart: () => {
          const rect = panelEl.getBoundingClientRect();
          const styles = getComputedStyle(document.documentElement);
          return {
            panelTop: rect.top,
            panelHeight: rect.height,
            currentR2: parseFloat(styles.getPropertyValue('--panel-r2')) || 20,
            currentR3: parseFloat(styles.getPropertyValue('--panel-r3')) || 20,
          };
        },
        onMove: (event, state) => {
          if (window.matchMedia('(orientation: landscape)').matches) {
            const rect = panelEl.getBoundingClientRect();
            const minLeft = 320;
            const minRight = 320;
            const leftPx = clamp(event.clientX - rect.left, minLeft, rect.width - minRight);
            const leftPct = (leftPx / rect.width) * 100;
            document.documentElement.style.setProperty('--panel-c1', `${leftPct}fr`);
            document.documentElement.style.setProperty('--panel-c2', `${100 - leftPct}fr`);
            return;
          }

          const minTop = 180;
          const minMid = 140;
          const minBottom = 120;
          const y = event.clientY - state.panelTop;
          const maxTop = state.panelHeight - (minMid + minBottom);
          const topPx = clamp(y, minTop, maxTop);
          const remain = state.panelHeight - topPx;
          const midRatio = state.currentR2 / (state.currentR2 + state.currentR3);
          const midPx = clamp(remain * midRatio, minMid, remain - minBottom);
          const bottomPx = remain - midPx;

          document.documentElement.style.setProperty('--panel-r1', `${topPx}fr`);
          document.documentElement.style.setProperty('--panel-r2', `${midPx}fr`);
          document.documentElement.style.setProperty('--panel-r3', `${bottomPx}fr`);
        },
      });

      setupResizer({
        handle: resizerBottom,
        cursor: 'row-resize',
        onStart: () => {
          const rect = panelEl.getBoundingClientRect();
          const styles = getComputedStyle(document.documentElement);
          return {
            panelTop: rect.top,
            panelHeight: rect.height,
            currentR1: parseFloat(styles.getPropertyValue('--panel-r1')) || 60,
            currentR2: parseFloat(styles.getPropertyValue('--panel-r2')) || 20,
            currentR3: parseFloat(styles.getPropertyValue('--panel-r3')) || 20,
          };
        },
        onMove: (event, state) => {
          if (window.matchMedia('(orientation: landscape)').matches) return;

          const minTop = 180;
          const minMid = 140;
          const minBottom = 120;
          const y = event.clientY - state.panelTop;
          const total = state.currentR1 + state.currentR2 + state.currentR3;
          const topPx = clamp((state.panelHeight * (state.currentR1 / total)), minTop, state.panelHeight - (minMid + minBottom));
          const maxY = state.panelHeight - minBottom;
          const boundaryPx = clamp(y, topPx + minMid, maxY);
          const midPx = boundaryPx - topPx;
          const bottomPx = state.panelHeight - boundaryPx;

          document.documentElement.style.setProperty('--panel-r2', `${midPx}fr`);
          document.documentElement.style.setProperty('--panel-r3', `${bottomPx}fr`);
        },
      });

      setupResizer({
        handle: stageResizer,
        cursor: 'row-resize',
        onStart: () => {
          const rect = stageShellEl?.getBoundingClientRect();
          if (!rect) return null;
          return { stageTop: rect.top, stageHeight: rect.height };
        },
        onMove: (event, state) => {
          const minStage = 180;
          const minChat = 140;
          const topPx = clamp(event.clientY - state.stageTop, minStage, state.stageHeight - minChat);
          document.documentElement.style.setProperty('--stage-r1', `${topPx}fr`);
          document.documentElement.style.setProperty('--stage-r2', `${state.stageHeight - topPx}fr`);
        },
      });

      setupResizer({
        handle: dashboardResizer,
        cursor: 'row-resize',
        onStart: () => {
          const rect = dashboardEl.getBoundingClientRect();
          return { dashboardTop: rect.top, dashboardHeight: rect.height };
        },
        onMove: (event, state) => {
          if (!window.matchMedia('(orientation: landscape)').matches) return;
          const minMain = 180;
          const minConsole = 140;
          const y = clamp(event.clientY - state.dashboardTop, minMain, state.dashboardHeight - minConsole);
          document.documentElement.style.setProperty('--dash-r1', `${y}fr`);
          document.documentElement.style.setProperty('--dash-r2', `${state.dashboardHeight - y}fr`);
        },
      });

      Promise.all([refreshState(), refreshChannels(), refreshTasks()])
        .then(() => {
          controlApiConnected = true;
          channelsApiConnected = true;
          status.textContent = 'å·²é€£ç·š Gateway æ§åˆ¶ API';
          appendLog('[system] å·²é€£ç·š Gateway æ§åˆ¶ API');
        })
        .catch((error) => {
          controlApiConnected = false;
          channelsApiConnected = false;
          setControlButtons({ start: false, pause: false, resume: false, stop: false });
          setAnimationMode('sleep');
          status.textContent = `ç„¡æ³•é€£ç·šæ§åˆ¶ APIï¼š${error.message}`;
          appendLog(`[error] ç„¡æ³•é€£ç·šæ§åˆ¶ APIï¼š${error.message}`);
          renderChannelsDisconnected('åˆå§‹é€£ç·šå¤±æ•—');
          renderFlow();
        });

      renderChannelsDisconnected('å°šæœªé€£ç·š');
      renderFlow();
    </script>
  </body>
</html>
