<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Agent Launch UI</title>
    <style>
      :root {
        --bg-1: #0f172a;
        --bg-2: #1e293b;
        --card: rgba(15, 23, 42, 0.75);
        --text: #e2e8f0;
        --primary: #38bdf8;
        --accent: #f472b6;
        --panel-r1: 60fr;
        --panel-r2: 20fr;
        --panel-r3: 20fr;
        --panel-c1: 1fr;
        --panel-c2: 1fr;
        --dash-r1: 60fr;
        --dash-r2: 40fr;
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Noto Sans TC", "Microsoft JhengHei", sans-serif;
        color: var(--text);
        background: radial-gradient(circle at top right, #334155, var(--bg-1) 45%),
          linear-gradient(135deg, var(--bg-1), var(--bg-2));
      }

      .panel {
        width: 100vw;
        height: 100vh;
        padding: 1rem;
        background: var(--card);
        border: 1px solid rgba(148, 163, 184, 0.2);
        backdrop-filter: blur(10px);
        display: grid;
        grid-template-rows: minmax(180px, var(--panel-r1)) 10px minmax(140px, var(--panel-r2)) 10px minmax(120px, var(--panel-r3));
        gap: 0.6rem;
      }


      .resizer {
        border-radius: 999px;
        background: rgba(56, 189, 248, 0.32);
        border: 1px solid rgba(125, 211, 252, 0.55);
        cursor: row-resize;
        position: relative;
      }

      .resizer::after {
        content: '';
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 58px;
        height: 3px;
        border-radius: 999px;
        background: rgba(186, 230, 253, 0.95);
      }

      .resizer:focus-visible {
        outline: 2px solid #22d3ee;
        outline-offset: 2px;
      }

      .panel-resizer-top { grid-row: 2; }
      .panel-resizer-bottom { grid-row: 4; }

      .dashboard h1 {
        margin: 0;
        font-size: clamp(1.1rem, 2.4vw, 1.5rem);
      }

      .dashboard p {
        line-height: 1.5;
        color: #cbd5e1;
        margin: 0.55rem 0 0.8rem;
        font-size: 0.9rem;
      }

      .start-btn {
        border: 0;
        border-radius: 999px;
        font-size: 0.95rem;
        font-weight: 700;
        letter-spacing: 0.02em;
        padding: 0.65rem 1.35rem;
        cursor: pointer;
        color: #0f172a;
        background: linear-gradient(135deg, var(--primary), #22d3ee);
        box-shadow: 0 12px 22px rgba(34, 211, 238, 0.35);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .start-btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 16px 26px rgba(34, 211, 238, 0.45);
      }

      .stage {
        position: relative;
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 20px;
        background: rgba(15, 23, 42, 0.45);
        overflow: hidden;
      }

      .stage-shell {
        display: grid;
        grid-template-rows: minmax(180px, 1fr) minmax(140px, 0.36fr);
        gap: 0.6rem;
      }

      .stage-chat {
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.62);
        padding: 0.7rem;
        display: flex;
        flex-direction: column;
        gap: 0.55rem;
      }

      .chat-log {
        margin: 0;
        flex: 1;
        min-height: 88px;
        overflow: auto;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        font-size: 0.75rem;
        color: #bfdbfe;
        white-space: pre-wrap;
      }

      .chat-form {
        display: grid;
        grid-template-columns: minmax(0, 1fr) auto;
        gap: 0.5rem;
      }

      .chat-input {
        width: 100%;
        border: 1px solid rgba(125, 211, 252, 0.45);
        border-radius: 10px;
        background: rgba(15, 23, 42, 0.72);
        color: #e2e8f0;
        padding: 0.55rem 0.65rem;
        font-size: 0.84rem;
      }

      .chat-send {
        border: 1px solid rgba(125, 211, 252, 0.45);
        border-radius: 10px;
        background: rgba(15, 23, 42, 0.82);
        color: #bae6fd;
        font-weight: 700;
        padding: 0.5rem 0.85rem;
        cursor: pointer;
      }

      .stage canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      .stage-controls {
        position: absolute;
        top: 0.65rem;
        left: 0.65rem;
        right: 0.65rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        z-index: 2;
      }

      .upload-label {
        border: 1px solid rgba(125, 211, 252, 0.45);
        background: rgba(15, 23, 42, 0.72);
        border-radius: 8px;
        padding: 0.32rem 0.55rem;
        font-size: 0.74rem;
        color: #bfdbfe;
        cursor: pointer;
      }

      .upload-label input {
        display: none;
      }

      .motion-btn {
        border: 1px solid rgba(125, 211, 252, 0.45);
        background: rgba(15, 23, 42, 0.72);
        color: #bae6fd;
        border-radius: 8px;
        padding: 0.32rem 0.55rem;
        font-size: 0.74rem;
        cursor: pointer;
      }

      .status {
        margin-top: 0.6rem;
        font-size: 0.95rem;
        color: #a5f3fc;
        min-height: 1.2em;
      }

      .dashboard,
      .console {
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.6);
        padding: 0.8rem;
        overflow: hidden;
      }

      .monitor {
        margin-top: 0.6rem;
        display: grid;
        gap: 0.8rem;
      }

      .pane {
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 14px;
        background: rgba(15, 23, 42, 0.6);
        padding: 0.75rem;
      }

      .metric-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 0.55rem;
      }

      .metric {
        border-radius: 10px;
        background: rgba(30, 41, 59, 0.8);
        border: 1px solid rgba(148, 163, 184, 0.15);
        padding: 0.55rem 0.65rem;
      }

      .metric .label {
        font-size: 0.75rem;
        color: #94a3b8;
      }

      .metric .value {
        margin-top: 0.2rem;
        font-size: 0.95rem;
        font-weight: 700;
        color: #e2e8f0;
      }

      .control-row {
        margin-top: 0.7rem;
        display: flex;
        gap: 0.55rem;
        flex-wrap: wrap;
      }

      .channel-grid {
        margin-top: 0.7rem;
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 0.55rem;
      }

      .channel-card {
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 12px;
        background: rgba(15, 23, 42, 0.62);
        padding: 0.55rem;
      }

      .channel-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
      }

      .channel-name {
        font-size: 0.8rem;
        font-weight: 700;
        color: #e2e8f0;
      }

      .channel-state {
        margin-top: 0.25rem;
        font-size: 0.72rem;
        color: #94a3b8;
      }

      .channel-toggle {
        border: 1px solid rgba(125, 211, 252, 0.45);
        background: rgba(15, 23, 42, 0.8);
        color: #bae6fd;
        border-radius: 8px;
        padding: 0.3rem 0.5rem;
        font-size: 0.72rem;
        cursor: pointer;
      }

      .ctrl-btn {
        border: 1px solid rgba(125, 211, 252, 0.45);
        background: rgba(15, 23, 42, 0.8);
        color: #bae6fd;
        border-radius: 8px;
        padding: 0.45rem 0.72rem;
        font-size: 0.78rem;
        cursor: pointer;
      }

      .ctrl-btn.stop {
        border-color: rgba(251, 113, 133, 0.55);
        color: #fecdd3;
      }

      .console-log {
        margin: 0;
        height: 100%;
        overflow: auto;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        font-size: 0.76rem;
        line-height: 1.45;
        color: #bfdbfe;
        white-space: pre-wrap;
      }

      .console h2 {
        margin: 0 0 0.5rem;
        font-size: 0.95rem;
      }

      .flow-card {
        margin-top: 0.7rem;
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 14px;
        background: rgba(15, 23, 42, 0.56);
        padding: 0.65rem;
      }

      .flow-card h3 {
        margin: 0 0 0.45rem;
        font-size: 0.82rem;
        color: #bfdbfe;
        letter-spacing: 0.02em;
      }

      .flow-help {
        margin: 0 0 0.55rem;
        font-size: 0.73rem;
        color: #94a3b8;
      }

      .flow-hint {
        margin-left: 0.4rem;
        color: #67e8f9;
      }

      .flow-svg {
        width: 100%;
        height: 260px;
        display: block;
        border-radius: 10px;
        background: rgba(15, 23, 42, 0.85);
      }

      .flow-legend {
        margin-top: 0.55rem;
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        font-size: 0.7rem;
        color: #cbd5e1;
      }

      .chip {
        border-radius: 999px;
        padding: 0.14rem 0.45rem;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(30, 41, 59, 0.6);
      }

      @media (orientation: landscape) {
        .panel {
          grid-template-columns: minmax(320px, var(--panel-c1)) 10px minmax(320px, var(--panel-c2));
          grid-template-rows: 1fr;
          gap: 0.6rem;
        }

        .stage-shell { grid-row: 1; grid-column: 1; }
        .panel-resizer-top {
          grid-row: 1;
          grid-column: 2;
          cursor: col-resize;
        }
        .panel-resizer-top::after {
          width: 3px;
          height: 58px;
        }
        .panel-resizer-bottom { display: none; }
        .dashboard { grid-row: 1; grid-column: 3; }

        .dashboard {
          display: grid;
          grid-template-rows: minmax(180px, var(--dash-r1)) 10px minmax(140px, var(--dash-r2));
          gap: 0.6rem;
        }

        .dashboard-resizer {
          grid-row: 2;
          cursor: row-resize;
        }

        .dashboard-main,
        .console-landscape {
          border: 1px solid rgba(148, 163, 184, 0.2);
          border-radius: 14px;
          background: rgba(15, 23, 42, 0.45);
          padding: 0.75rem;
          overflow: hidden;
        }

        .console { display: none; }
        .console-landscape { display: block; }
      }

      @media (orientation: portrait) {
        .dashboard-main { display: block; }
        .console-landscape { display: none; }
        .dashboard-resizer { display: none; }
      }
    </style>
  </head>
  <body>
    <main class="panel">
      <section class="stage-shell" aria-label="å·¦å´å·¥ä½œå€">
        <section class="stage" aria-label="ç…§ç‰‡äººç‰© 2D å‹•ä½œæ¨¡æ“¬å€">
          <div class="stage-controls">
            <label class="upload-label">ä¸Šå‚³ç…§ç‰‡
              <input id="photoInput" type="file" accept="image/*" />
            </label>
            <button id="motionToggle" class="motion-btn" type="button">æš«åœå‹•ä½œ</button>
            <button id="pauseAndClearStage" class="motion-btn" type="button">æš«åœä¸¦æ¸…ç•«é¢</button>
          </div>
          <canvas id="motionCanvas" width="960" height="640" role="img" aria-label="ç…§ç‰‡äººç‰© 2D éª¨æ¶å‹•ä½œæ¨¡æ“¬"></canvas>
        </section>

        <section class="stage-chat" aria-label="æŒ‡ä»¤å°è©±æ¡†">
          <h2 style="margin:0;font-size:0.92rem;">Agent å°è©±è¼¸å…¥æ¡†</h2>
          <pre id="chatLog" class="chat-log">[chat] å¯åœ¨æ­¤è¼¸å…¥æŒ‡ä»¤ï¼Œé€è‡³ Gateway -> AnythingLLM</pre>
          <form id="chatForm" class="chat-form">
            <input id="chatInput" class="chat-input" type="text" placeholder="ä¾‹å¦‚ï¼šè«‹æ•´ç†ä»Šå¤©å‘Šè­¦ä¸¦æå‡ºè™•ç½®æ­¥é©Ÿ" required />
            <button id="chatSend" class="chat-send" type="submit">é€å‡º</button>
          </form>
        </section>
      </section>

      <div id="resizerTop" class="resizer panel-resizer-top" role="separator" aria-orientation="horizontal" tabindex="0" aria-label="èª¿æ•´ä¸Šæ–¹èˆ‡ä¸­é–“å€å¡Šé«˜åº¦"></div>

      <section class="dashboard">
        <div class="dashboard-main">
          <h1>Agent å•Ÿå‹•é¢æ¿</h1>
          <p>æ­¡è¿ä½¿ç”¨ Agent æ§åˆ¶å°ã€‚æŒ‰ä¸‹æŒ‰éˆ•å¾Œï¼Œç³»çµ±æœƒåˆå§‹åŒ–æµç¨‹ä¸¦é–‹å§‹åŸ·è¡Œä»»å‹™ã€‚</p>
          <button id="startAgent" class="start-btn" type="button">Start Agent</button>
          <p id="status" class="status" aria-live="polite"></p>

          <section class="monitor" aria-label="Agent dashboard">
            <section id="dashboardPane" class="pane" role="region" aria-label="dashboard">
            <div class="metric-grid">
              <article class="metric">
                <div class="label">åŠ©æ‰‹ç‹€æ…‹</div>
                <div id="assistantStatus" class="value">Idle</div>
              </article>
              <article class="metric">
                <div class="label">åŸ·è¡Œç‹€æ…‹</div>
                <div id="executionStatus" class="value">æœªåŸ·è¡Œ</div>
              </article>
              <article class="metric">
                <div class="label">é€²åº¦</div>
                <div id="taskProgress" class="value">0%</div>
              </article>
              <article class="metric">
                <div class="label">ç›®å‰ä»»å‹™åŸ·è¡Œæ™‚é–“</div>
                <div id="taskElapsed" class="value">00:00:00</div>
              </article>
              <article class="metric">
                <div class="label">æœ€å¾Œæ›´æ–°</div>
                <div id="lastUpdated" class="value">--:--:--</div>
              </article>
            </div>
            <div class="control-row">
              <button id="pauseAgent" class="ctrl-btn" type="button">æš«åœä»»å‹™</button>
              <button id="resumeAgent" class="ctrl-btn" type="button">æ¢å¾©ä»»å‹™</button>
              <button id="stopAgent" class="ctrl-btn stop" type="button">åœæ­¢ Agent</button>
              <button id="clearConsole" class="ctrl-btn" type="button">æ¸…é™¤ Console</button>
            </div>

            <article class="flow-card" aria-label="é€£å…¥æ¥å£æ§åˆ¶">
              <h3>é€£å…¥æ¥å£å¡ç‰‡èˆ‡é–‹é—œ</h3>
              <p class="flow-help">å¯ç¨ç«‹å•Ÿç”¨/åœç”¨æ¯å€‹æ¥å£ï¼›åœç”¨å¾Œè©²æ¥å£ ingress æœƒå›å‚³ 503ã€‚</p>
              <div class="channel-grid">
                <section class="channel-card" data-channel-card="telegram">
                  <div class="channel-head">
                    <span class="channel-name">Telegram</span>
                    <button class="channel-toggle" data-channel-toggle="telegram" type="button">åˆ‡æ›</button>
                  </div>
                  <div id="channelStateTelegram" class="channel-state">ç‹€æ…‹è®€å–ä¸­...</div>
                </section>
                <section class="channel-card" data-channel-card="line">
                  <div class="channel-head">
                    <span class="channel-name">LINE</span>
                    <button class="channel-toggle" data-channel-toggle="line" type="button">åˆ‡æ›</button>
                  </div>
                  <div id="channelStateLine" class="channel-state">ç‹€æ…‹è®€å–ä¸­...</div>
                </section>
                <section class="channel-card" data-channel-card="web_ui">
                  <div class="channel-head">
                    <span class="channel-name">Web UI</span>
                    <button class="channel-toggle" data-channel-toggle="web_ui" type="button">åˆ‡æ›</button>
                  </div>
                  <div id="channelStateWebUi" class="channel-state">ç‹€æ…‹è®€å–ä¸­...</div>
                </section>
              </div>
            </article>

            <article class="flow-card" aria-label="API è³‡æ–™æµ">
              <h3>API è³‡æ–™æµæ‹“æ¨¸ï¼ˆå¡ç‰‡å¼ï¼‰</h3>
              <p class="flow-help">ä»¥æ–¹å¡Šå¡ç‰‡å‘ˆç¾ç›®å‰å…ƒä»¶ï¼ˆUI / Gateway / AnythingLLM / Ollama / gpt-oss:20bï¼‰ï¼Œé€£ç·šæ—æ¨™ç¤ºé€šè¨Šæ–¹å¼ï¼ˆAPI / Local Runtimeï¼‰ã€‚<span class="flow-hint">å¯ç›´æ¥æ‹–æ›³å¡ç‰‡èª¿æ•´æ‹“æ¨¸ã€‚</span></p>
              <svg id="flowSvg" class="flow-svg" viewBox="0 0 980 300" role="img" aria-label="UI åˆ° LLM çš„å¯¦éš›è³‡æ–™æµèˆ‡é€šè¨Šæ–¹å¼"></svg>
              <div class="flow-legend">
                <span class="chip">ğŸŸ¢ Active path</span>
                <span class="chip">ğŸŸ¡ Paused path</span>
                <span class="chip">ğŸ”¹ HTTP API / Webhook</span>
                <span class="chip">ğŸ§  Local runtime / provider call</span>
              </div>
            </article>
          </section>
          </section>
        </div>

        <div id="dashboardResizer" class="resizer dashboard-resizer" role="separator" aria-orientation="horizontal" tabindex="0" aria-label="èª¿æ•´å³å´é¢æ¿èˆ‡ Console é«˜åº¦"></div>

        <section class="console-landscape" aria-label="console">
          <h2>Console</h2>
          <pre id="consoleLogLandscape" class="console-log">[system] ç­‰å¾…å•Ÿå‹•æŒ‡ä»¤...</pre>
        </section>
      </section>

      <div id="resizerBottom" class="resizer panel-resizer-bottom" role="separator" aria-orientation="horizontal" tabindex="0" aria-label="èª¿æ•´ä¸­é–“èˆ‡ä¸‹æ–¹å€å¡Šé«˜åº¦"></div>

      <section class="console" aria-label="console">
        <h2>Console</h2>
        <section id="consolePane" class="pane" role="region" aria-label="console">
            <pre id="consoleLog" class="console-log">[system] ç­‰å¾…å•Ÿå‹•æŒ‡ä»¤...</pre>
        </section>
      </section>
    </main>

    <script>
      const button = document.getElementById('startAgent');
      const status = document.getElementById('status');
      const assistantStatus = document.getElementById('assistantStatus');
      const executionStatus = document.getElementById('executionStatus');
      const taskProgress = document.getElementById('taskProgress');
      const taskElapsed = document.getElementById('taskElapsed');
      const lastUpdated = document.getElementById('lastUpdated');
      const consoleLog = document.getElementById('consoleLog');
      const consoleLogLandscape = document.getElementById('consoleLogLandscape');
      const pauseBtn = document.getElementById('pauseAgent');
      const resumeBtn = document.getElementById('resumeAgent');
      const stopBtn = document.getElementById('stopAgent');
      const clearConsoleBtn = document.getElementById('clearConsole');
      const channelStateTelegram = document.getElementById('channelStateTelegram');
      const channelStateLine = document.getElementById('channelStateLine');
      const channelStateWebUi = document.getElementById('channelStateWebUi');
      const channelToggleButtons = document.querySelectorAll('[data-channel-toggle]');
      const flowSvg = document.getElementById('flowSvg');
      const photoInput = document.getElementById('photoInput');
      const motionToggle = document.getElementById('motionToggle');
      const pauseAndClearStageBtn = document.getElementById('pauseAndClearStage');
      const chatForm = document.getElementById('chatForm');
      const chatInput = document.getElementById('chatInput');
      const chatLog = document.getElementById('chatLog');
      const motionCanvas = document.getElementById('motionCanvas');
      const motionCtx = motionCanvas.getContext('2d');
      const panelEl = document.querySelector('.panel');
      const dashboardEl = document.querySelector('.dashboard');
      const resizerTop = document.getElementById('resizerTop');
      const resizerBottom = document.getElementById('resizerBottom');
      const dashboardResizer = document.getElementById('dashboardResizer');

      let runningMotion = true;
      let backgroundImage = null;

      const flowConfig = {
        viewBox: { width: 980, height: 300 },
        nodes: [
          { id: 'ui', title: 'Dashboard UI', subtitle: 'approval_ui/index.html', x: 30, y: 105, w: 180, h: 78, kind: 'control' },
          { id: 'gateway', title: 'Gateway', subtitle: '/api/agent/control', x: 250, y: 105, w: 180, h: 78, kind: 'core' },
          { id: 'anythingllm', title: 'AnythingLLM', subtitle: 'Developer API /chat', x: 470, y: 105, w: 180, h: 78, kind: 'brain' },
          { id: 'ollama', title: 'Ollama', subtitle: 'Model Provider', x: 700, y: 40, w: 180, h: 78, kind: 'integration' },
          { id: 'gptoss', title: 'gpt-oss:20b (LLM)', subtitle: 'Inference Runtime', x: 700, y: 180, w: 180, h: 78, kind: 'integration' },
        ],
        edges: [
          { from: 'ui', to: 'gateway', label: 'HTTP API: GET/POST /api/agent/control' },
          { from: 'gateway', to: 'anythingllm', label: 'HTTP API: /api/v1/workspace/:id/chat' },
          { from: 'anythingllm', to: 'ollama', label: 'Provider API call' },
          { from: 'ollama', to: 'gptoss', label: 'Local model runtime' },
        ],
      };

      const flowNodes = flowConfig.nodes.map((node) => ({ ...node }));
      let flowLastControlState = null;
      let flowDragState = null;

      const basePose = {
        head: { x: 460, y: 160 },
        neck: { x: 460, y: 210 },
        shoulderL: { x: 415, y: 235 },
        shoulderR: { x: 505, y: 235 },
        elbowL: { x: 390, y: 300 },
        elbowR: { x: 540, y: 300 },
        handL: { x: 368, y: 360 },
        handR: { x: 580, y: 360 },
        hip: { x: 460, y: 365 },
        kneeL: { x: 430, y: 470 },
        kneeR: { x: 490, y: 470 },
        footL: { x: 410, y: 590 },
        footR: { x: 510, y: 590 },
      };

      const drawBone = (a, b, width = 5, color = '#38bdf8') => {
        motionCtx.beginPath();
        motionCtx.moveTo(a.x, a.y);
        motionCtx.lineTo(b.x, b.y);
        motionCtx.lineWidth = width;
        motionCtx.strokeStyle = color;
        motionCtx.stroke();
      };

      const drawJoint = (joint, color = '#e2e8f0') => {
        motionCtx.beginPath();
        motionCtx.arc(joint.x, joint.y, 5, 0, Math.PI * 2);
        motionCtx.fillStyle = color;
        motionCtx.fill();
      };

      const drawSkeleton = (pose) => {
        drawBone(pose.head, pose.neck, 3);
        drawBone(pose.neck, pose.shoulderL);
        drawBone(pose.neck, pose.shoulderR);
        drawBone(pose.shoulderL, pose.elbowL);
        drawBone(pose.elbowL, pose.handL);
        drawBone(pose.shoulderR, pose.elbowR);
        drawBone(pose.elbowR, pose.handR);
        drawBone(pose.neck, pose.hip, 6);
        drawBone(pose.hip, pose.kneeL);
        drawBone(pose.kneeL, pose.footL);
        drawBone(pose.hip, pose.kneeR);
        drawBone(pose.kneeR, pose.footR);
        Object.values(pose).forEach((joint) => drawJoint(joint));
      };

      const loadPhoto = (file) => new Promise((resolve, reject) => {
        const image = new Image();
        image.onload = () => resolve(image);
        image.onerror = reject;
        image.src = URL.createObjectURL(file);
      });

      photoInput.addEventListener('change', async (event) => {
        const file = event.target.files?.[0];
        if (!file) return;
        try {
          backgroundImage = await loadPhoto(file);
          appendLog(`[stage] å·²è¼‰å…¥ç…§ç‰‡ï¼š${file.name}`);
        } catch (error) {
          appendLog(`[error] ç…§ç‰‡è¼‰å…¥å¤±æ•—ï¼š${error.message}`);
        }
      });

      motionToggle.addEventListener('click', () => {
        runningMotion = !runningMotion;
        motionToggle.textContent = runningMotion ? 'æš«åœå‹•ä½œ' : 'ç¹¼çºŒå‹•ä½œ';
        if (runningMotion) {
          requestAnimationFrame(renderMotion);
        }
      });

      const clearStageCanvas = () => {
        motionCtx.clearRect(0, 0, motionCanvas.width, motionCanvas.height);
        motionCtx.fillStyle = '#020617';
        motionCtx.fillRect(0, 0, motionCanvas.width, motionCanvas.height);
      };

      pauseAndClearStageBtn.addEventListener('click', () => {
        runningMotion = false;
        backgroundImage = null;
        motionToggle.textContent = 'ç¹¼çºŒå‹•ä½œ';
        clearStageCanvas();
        appendLog('[stage] å·²æš«åœå‹•ç•«ä¸¦æ¸…é™¤å·¦å´ç•«é¢');
      });

      const renderMotion = (timestamp) => {
        motionCtx.clearRect(0, 0, motionCanvas.width, motionCanvas.height);

        if (backgroundImage) {
          const ratio = Math.min(motionCanvas.width / backgroundImage.width, motionCanvas.height / backgroundImage.height);
          const drawWidth = backgroundImage.width * ratio;
          const drawHeight = backgroundImage.height * ratio;
          const x = (motionCanvas.width - drawWidth) / 2;
          const y = (motionCanvas.height - drawHeight) / 2;
          motionCtx.drawImage(backgroundImage, x, y, drawWidth, drawHeight);
        } else {
          motionCtx.fillStyle = '#0f172a';
          motionCtx.fillRect(0, 0, motionCanvas.width, motionCanvas.height);
          motionCtx.fillStyle = '#94a3b8';
          motionCtx.font = '600 20px "Noto Sans TC", sans-serif';
          motionCtx.fillText('ä¸Šå‚³ç…§ç‰‡å¾Œï¼Œå¯åœ¨å·¦å´çœ‹åˆ° 2D éª¨æ¶æ®æ‰‹æ¨¡æ“¬ã€‚', 170, 56);
        }

        const phase = timestamp * 0.004;
        const pose = structuredClone(basePose);
        pose.elbowR.y = basePose.elbowR.y - (Math.sin(phase) * 52);
        pose.handR.y = basePose.handR.y - (Math.sin(phase) * 88);
        pose.handR.x = basePose.handR.x + (Math.cos(phase) * 22);
        drawSkeleton(pose);

        if (runningMotion) {
          requestAnimationFrame(renderMotion);
        }
      };

      requestAnimationFrame(renderMotion);

      const toLocalTime = (iso) => {
        if (!iso) return '--:--:--';
        return new Date(iso).toLocaleTimeString('zh-Hant-TW', { hour12: false });
      };

      const appendLog = (text) => {
        [consoleLog, consoleLogLandscape].forEach((targetLog) => {
          targetLog.textContent += `\n${text}`;
          targetLog.scrollTop = targetLog.scrollHeight;
        });
      };

      const appendChatLog = (speaker, text) => {
        chatLog.textContent += `\n[${speaker}] ${text}`;
        chatLog.scrollTop = chatLog.scrollHeight;
      };

      const pad2 = (value) => String(value).padStart(2, '0');
      const formatDuration = (totalMs) => {
        const totalSeconds = Math.max(0, Math.floor(totalMs / 1000));
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        return `${pad2(hours)}:${pad2(minutes)}:${pad2(seconds)}`;
      };

      let taskElapsedMs = 0;
      let taskRunStartedAtMs = null;
      let taskTimerId = null;
      let currentRunState = 'idle';

      const renderTaskElapsed = () => {
        if (!taskElapsed) return;
        const runningDelta = taskRunStartedAtMs ? (Date.now() - taskRunStartedAtMs) : 0;
        taskElapsed.textContent = formatDuration(taskElapsedMs + runningDelta);
      };

      const ensureTaskTimer = () => {
        if (taskTimerId) return;
        taskTimerId = window.setInterval(renderTaskElapsed, 1000);
      };

      const clearTaskTimer = () => {
        if (!taskTimerId) return;
        window.clearInterval(taskTimerId);
        taskTimerId = null;
      };

      const reconcileTaskElapsed = (nextState) => {
        if (nextState === 'idle' || nextState === 'stopped') {
          taskElapsedMs = 0;
          taskRunStartedAtMs = null;
          clearTaskTimer();
          renderTaskElapsed();
          currentRunState = nextState;
          return;
        }

        if (nextState === 'running') {
          if (currentRunState !== 'running') {
            taskRunStartedAtMs = Date.now();
          }
          ensureTaskTimer();
          renderTaskElapsed();
          currentRunState = nextState;
          return;
        }

        if (nextState === 'paused') {
          if (taskRunStartedAtMs) {
            taskElapsedMs += Date.now() - taskRunStartedAtMs;
            taskRunStartedAtMs = null;
          }
          clearTaskTimer();
          renderTaskElapsed();
          currentRunState = nextState;
        }
      };

      const clientToFlowPoint = (clientX, clientY) => {
        const rect = flowSvg.getBoundingClientRect();
        const scaleX = flowConfig.viewBox.width / rect.width;
        const scaleY = flowConfig.viewBox.height / rect.height;
        return {
          x: (clientX - rect.left) * scaleX,
          y: (clientY - rect.top) * scaleY,
        };
      };

      const startFlowDrag = (event) => {
        if (event.button !== 0 || !flowSvg) return;
        const nodeGroup = event.target.closest('[data-node-id]');
        if (!nodeGroup) return;

        const nodeId = nodeGroup.dataset.nodeId;
        const node = flowNodes.find((item) => item.id === nodeId);
        if (!node) return;

        const pointer = clientToFlowPoint(event.clientX, event.clientY);
        flowDragState = {
          node,
          pointerId: event.pointerId,
          offsetX: pointer.x - node.x,
          offsetY: pointer.y - node.y,
        };

        flowSvg.setPointerCapture(event.pointerId);
      };

      const moveFlowDrag = (event) => {
        if (!flowDragState || flowDragState.pointerId !== event.pointerId) return;

        const pointer = clientToFlowPoint(event.clientX, event.clientY);
        const { node, offsetX, offsetY } = flowDragState;
        node.x = clamp(pointer.x - offsetX, 10, flowConfig.viewBox.width - node.w - 10);
        node.y = clamp(pointer.y - offsetY, 10, flowConfig.viewBox.height - node.h - 10);

        renderFlow(flowLastControlState);
      };

      const endFlowDrag = (event) => {
        if (!flowDragState || flowDragState.pointerId !== event.pointerId) return;
        flowSvg.releasePointerCapture(event.pointerId);
        flowDragState = null;
      };

      flowSvg?.addEventListener('pointerdown', startFlowDrag);
      flowSvg?.addEventListener('pointermove', moveFlowDrag);
      flowSvg?.addEventListener('pointerup', endFlowDrag);
      flowSvg?.addEventListener('pointercancel', endFlowDrag);

      const renderFlow = (controlState) => {
        if (!flowSvg) return;
        flowLastControlState = controlState;

        const nodeMap = new Map(flowNodes.map((node) => [node.id, node]));
        const isActive = controlState?.assistant_status === 'Running';
        const isPaused = controlState?.assistant_status === 'Paused';

        const edgeColor = isActive ? '#22d3ee' : (isPaused ? '#f59e0b' : '#64748b');

        const edgeMarkup = flowConfig.edges.map((edge) => {
          const from = nodeMap.get(edge.from);
          const to = nodeMap.get(edge.to);
          if (!from || !to) return '';

          const startX = from.x + from.w;
          const startY = from.y + (from.h / 2);
          const endX = to.x;
          const endY = to.y + (to.h / 2);
          const bendX = (startX + endX) / 2;
          const path = `M ${startX} ${startY} C ${bendX} ${startY}, ${bendX} ${endY}, ${endX} ${endY}`;

          const labelX = bendX;
          const labelY = ((startY + endY) / 2) - 8;

          return `
            <path d="${path}" fill="none" stroke="${edgeColor}" stroke-width="3" marker-end="url(#arrowhead)" opacity="0.9" />
            <rect x="${labelX - 130}" y="${labelY - 11}" width="260" height="18" rx="9" fill="rgba(15,23,42,0.95)" stroke="rgba(148,163,184,0.35)" />
            <text x="${labelX}" y="${labelY + 2}" fill="#cbd5e1" font-size="11" text-anchor="middle">${edge.label}</text>
          `;
        }).join('');

        const nodeMarkup = flowNodes.map((node) => {
          const fillByKind = {
            integration: '#0f172a',
            core: '#0b253a',
            control: '#1e1b4b',
            brain: '#032d39',
          };

          const activeNode = isActive && ['gateway', 'anythingllm', 'ollama', 'gptoss'].includes(node.id);
          const pausedNode = isPaused && ['gateway', 'anythingllm'].includes(node.id);
          const stroke = activeNode ? '#22d3ee' : (pausedNode ? '#f59e0b' : '#64748b');
          const titleX = node.x + 12;
          const titleY = node.y + 28;

          return `
            <g data-node-id="${node.id}" style="cursor: grab;">
              <rect x="${node.x}" y="${node.y}" width="${node.w}" height="${node.h}" rx="12" fill="${fillByKind[node.kind] || '#0f172a'}" stroke="${stroke}" stroke-width="2.5" />
              <text x="${titleX}" y="${titleY}" fill="#e2e8f0" font-size="14" font-weight="700">${node.title}</text>
              <text x="${titleX}" y="${titleY + 20}" fill="#94a3b8" font-size="11">${node.subtitle}</text>
            </g>
          `;
        }).join('');

        flowSvg.innerHTML = `
          <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="8" refY="3.5" orient="auto">
              <polygon points="0 0, 10 3.5, 0 7" fill="#94a3b8"></polygon>
            </marker>
          </defs>
          <g>
            ${edgeMarkup}
            ${nodeMarkup}
          </g>
        `;
      };

      const applyControlState = (data) => {
        reconcileTaskElapsed(data.state);
        assistantStatus.textContent = data.assistant_status;
        executionStatus.textContent = data.execution_status;
        taskProgress.textContent = `${data.task_progress}%`;
        lastUpdated.textContent = toLocalTime(data.last_updated_at);

        button.disabled = !data.can.start;
        pauseBtn.disabled = !data.can.pause;
        resumeBtn.disabled = !data.can.resume;
        stopBtn.disabled = !data.can.stop;
        renderFlow(data);
      };

      const renderChannels = (channels) => {
        const mapping = {
          telegram: channelStateTelegram,
          line: channelStateLine,
          web_ui: channelStateWebUi,
        };

        Object.entries(mapping).forEach(([key, target]) => {
          const item = channels[key];
          if (!item) return;
          target.textContent = item.enabled ? 'ç›®å‰ï¼šå•Ÿç”¨' : 'ç›®å‰ï¼šåœç”¨';
          target.style.color = item.enabled ? '#67e8f9' : '#fda4af';
          const button = document.querySelector(`[data-channel-toggle="${key}"]`);
          if (button) button.textContent = item.enabled ? 'é—œé–‰' : 'é–‹å•Ÿ';
        });
      };

      const refreshChannels = async () => {
        const response = await fetch('/api/channels');
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'è®€å–æ¥å£ç‹€æ…‹å¤±æ•—');
        }
        renderChannels(payload.data);
      };

      const toggleChannel = async (channel, enabled) => {
        const response = await fetch('/api/channels', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ channel, enabled }),
        });
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'åˆ‡æ›æ¥å£å¤±æ•—');
        }
        renderChannels(payload.data);
      };

      const refreshState = async () => {
        const response = await fetch('/api/agent/control');
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'è®€å– Agent ç‹€æ…‹å¤±æ•—');
        }
        applyControlState(payload.data);
      };

      const sendControl = async (action) => {
        const response = await fetch('/api/agent/control', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action }),
        });
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || `${action} å¤±æ•—`);
        }
        applyControlState(payload.data);
        return payload.data;
      };

      const sendCommand = async (text) => {
        const response = await fetch('/api/agent/command', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text }),
        });
        const payload = await response.json();
        if (!response.ok || !payload.ok) {
          throw new Error(payload.error || 'ç™¼é€æŒ‡ä»¤å¤±æ•—');
        }
        return payload.reply;
      };

      button.addEventListener('click', async () => {
        try {
          status.textContent = 'Agent å•Ÿå‹•ä¸­...';
          await sendControl('start');
          status.textContent = 'Agent å·²å•Ÿå‹•ï¼Œç§˜æ›¸å¾…å‘½ä¸­ã€‚';
          appendLog('[control] ä½¿ç”¨è€…å•Ÿå‹• Agent');
        } catch (error) {
          status.textContent = `å•Ÿå‹•å¤±æ•—ï¼š${error.message}`;
          appendLog(`[error] å•Ÿå‹•å¤±æ•—ï¼š${error.message}`);
        }
      });

      pauseBtn.addEventListener('click', async () => {
        try {
          await sendControl('pause');
          status.textContent = 'Agent å·²æš«åœã€‚';
          appendLog('[control] ä½¿ç”¨è€…æš«åœä»»å‹™');
        } catch (error) {
          status.textContent = `æš«åœå¤±æ•—ï¼š${error.message}`;
          appendLog(`[error] æš«åœå¤±æ•—ï¼š${error.message}`);
        }
      });

      resumeBtn.addEventListener('click', async () => {
        try {
          await sendControl('resume');
          status.textContent = 'Agent å·²æ¢å¾©åŸ·è¡Œã€‚';
          appendLog('[control] ä½¿ç”¨è€…æ¢å¾©ä»»å‹™');
        } catch (error) {
          status.textContent = `æ¢å¾©å¤±æ•—ï¼š${error.message}`;
          appendLog(`[error] æ¢å¾©å¤±æ•—ï¼š${error.message}`);
        }
      });

      stopBtn.addEventListener('click', async () => {
        try {
          await sendControl('stop');
          status.textContent = 'Agent å·²åœæ­¢ã€‚';
          appendLog('[control] ä½¿ç”¨è€…åœæ­¢ Agent');
        } catch (error) {
          status.textContent = `åœæ­¢å¤±æ•—ï¼š${error.message}`;
          appendLog(`[error] åœæ­¢å¤±æ•—ï¼š${error.message}`);
        }
      });


      chatForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        const text = chatInput.value.trim();
        if (!text) return;

        chatInput.disabled = true;
        appendChatLog('user', text);
        appendLog(`[command] UI æŒ‡ä»¤é€å‡ºï¼š${text}`);

        try {
          const reply = await sendCommand(text);
          appendChatLog('agent', reply);
          status.textContent = 'å·²æ”¶åˆ° Agent å›è¦†ã€‚';
          appendLog('[command] æŒ‡ä»¤å®Œæˆ');
        } catch (error) {
          appendChatLog('error', error.message);
          status.textContent = `æŒ‡ä»¤å¤±æ•—ï¼š${error.message}`;
          appendLog(`[error] æŒ‡ä»¤å¤±æ•—ï¼š${error.message}`);
        } finally {
          chatInput.disabled = false;
          chatInput.value = '';
          chatInput.focus();
        }
      });

      channelToggleButtons.forEach((buttonEl) => {
        buttonEl.addEventListener('click', async () => {
          const channel = buttonEl.dataset.channelToggle;
          const currentLabel = buttonEl.textContent;
          const nextEnabled = currentLabel === 'é–‹å•Ÿ';
          buttonEl.disabled = true;
          try {
            await toggleChannel(channel, nextEnabled);
            appendLog(`[channel] ${channel} å·²${nextEnabled ? 'é–‹å•Ÿ' : 'é—œé–‰'}`);
          } catch (error) {
            status.textContent = `æ¥å£åˆ‡æ›å¤±æ•—ï¼š${error.message}`;
            appendLog(`[error] æ¥å£åˆ‡æ›å¤±æ•—ï¼š${error.message}`);
          } finally {
            buttonEl.disabled = false;
          }
        });
      });

      clearConsoleBtn.addEventListener('click', () => {
        [consoleLog, consoleLogLandscape].forEach((targetLog) => {
          targetLog.textContent = '[system] console å·²æ¸…ç©º';
        });
        lastUpdated.textContent = toLocalTime(new Date().toISOString());
      });


      const clamp = (value, min, max) => Math.max(min, Math.min(value, max));

      const setupResizer = ({ handle, onStart, onMove, onEnd, cursor }) => {
        if (!handle) return;

        handle.addEventListener('mousedown', (event) => {
          event.preventDefault();
          const startState = onStart(event);
          if (!startState) return;
          document.body.style.cursor = cursor;
          document.body.style.userSelect = 'none';

          const onMouseMove = (moveEvent) => onMove(moveEvent, startState);
          const onMouseUp = () => {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            if (onEnd) onEnd();
          };

          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });
      };

      setupResizer({
        handle: resizerTop,
        cursor: 'row-resize',
        onStart: () => {
          const rect = panelEl.getBoundingClientRect();
          const styles = getComputedStyle(document.documentElement);
          return {
            panelTop: rect.top,
            panelHeight: rect.height,
            currentR2: parseFloat(styles.getPropertyValue('--panel-r2')) || 20,
            currentR3: parseFloat(styles.getPropertyValue('--panel-r3')) || 20,
          };
        },
        onMove: (event, state) => {
          if (window.matchMedia('(orientation: landscape)').matches) {
            const rect = panelEl.getBoundingClientRect();
            const minLeft = 320;
            const minRight = 320;
            const leftPx = clamp(event.clientX - rect.left, minLeft, rect.width - minRight);
            const leftPct = (leftPx / rect.width) * 100;
            document.documentElement.style.setProperty('--panel-c1', `${leftPct}fr`);
            document.documentElement.style.setProperty('--panel-c2', `${100 - leftPct}fr`);
            return;
          }

          const minTop = 180;
          const minMid = 140;
          const minBottom = 120;
          const y = event.clientY - state.panelTop;
          const maxTop = state.panelHeight - (minMid + minBottom);
          const topPx = clamp(y, minTop, maxTop);
          const remain = state.panelHeight - topPx;
          const midRatio = state.currentR2 / (state.currentR2 + state.currentR3);
          const midPx = clamp(remain * midRatio, minMid, remain - minBottom);
          const bottomPx = remain - midPx;

          document.documentElement.style.setProperty('--panel-r1', `${topPx}fr`);
          document.documentElement.style.setProperty('--panel-r2', `${midPx}fr`);
          document.documentElement.style.setProperty('--panel-r3', `${bottomPx}fr`);
        },
      });

      setupResizer({
        handle: resizerBottom,
        cursor: 'row-resize',
        onStart: () => {
          const rect = panelEl.getBoundingClientRect();
          const styles = getComputedStyle(document.documentElement);
          return {
            panelTop: rect.top,
            panelHeight: rect.height,
            currentR1: parseFloat(styles.getPropertyValue('--panel-r1')) || 60,
            currentR2: parseFloat(styles.getPropertyValue('--panel-r2')) || 20,
            currentR3: parseFloat(styles.getPropertyValue('--panel-r3')) || 20,
          };
        },
        onMove: (event, state) => {
          if (window.matchMedia('(orientation: landscape)').matches) return;

          const minTop = 180;
          const minMid = 140;
          const minBottom = 120;
          const y = event.clientY - state.panelTop;
          const total = state.currentR1 + state.currentR2 + state.currentR3;
          const topPx = clamp((state.panelHeight * (state.currentR1 / total)), minTop, state.panelHeight - (minMid + minBottom));
          const maxY = state.panelHeight - minBottom;
          const boundaryPx = clamp(y, topPx + minMid, maxY);
          const midPx = boundaryPx - topPx;
          const bottomPx = state.panelHeight - boundaryPx;

          document.documentElement.style.setProperty('--panel-r2', `${midPx}fr`);
          document.documentElement.style.setProperty('--panel-r3', `${bottomPx}fr`);
        },
      });

      setupResizer({
        handle: dashboardResizer,
        cursor: 'row-resize',
        onStart: () => {
          const rect = dashboardEl.getBoundingClientRect();
          return { dashboardTop: rect.top, dashboardHeight: rect.height };
        },
        onMove: (event, state) => {
          if (!window.matchMedia('(orientation: landscape)').matches) return;
          const minMain = 180;
          const minConsole = 140;
          const y = clamp(event.clientY - state.dashboardTop, minMain, state.dashboardHeight - minConsole);
          document.documentElement.style.setProperty('--dash-r1', `${y}fr`);
          document.documentElement.style.setProperty('--dash-r2', `${state.dashboardHeight - y}fr`);
        },
      });

      Promise.all([refreshState(), refreshChannels()])
        .then(() => appendLog('[system] å·²é€£ç·š Gateway æ§åˆ¶ API'))
        .catch((error) => {
          status.textContent = `ç„¡æ³•é€£ç·šæ§åˆ¶ APIï¼š${error.message}`;
          appendLog(`[error] ç„¡æ³•é€£ç·šæ§åˆ¶ APIï¼š${error.message}`);
          renderFlow();
        });

      renderFlow();
    </script>
  </body>
</html>
